import{UpdateCommand as e,isUpdateCommand as t,UPDATE_COMMANDS_LITERAL as a}from"../commands/update";import{SYMBOL_UNSET_FIELD_NAME as o}from"../helper/symbol";import{getType as r}from"../utils/type";import{operatorToString as n}from"../operator-map";import{flattenQueryObject as d,encodeInternalDataType as c,mergeConditionAfterEncode as s}from"./common";export class UpdateSerializer{constructor(){}static encode(e){return(new UpdateSerializer).encodeUpdate(e)}encodeUpdate(e){return t(e)?this.encodeUpdateCommand(e):"object"===r(e)?this.encodeUpdateObject(e):e}encodeUpdateCommand(e){if(e.fieldName===o)throw new Error("Cannot encode a comparison command with unset field name");switch(e.operator){case a.SET:case a.REMOVE:case a.INC:case a.MUL:return this.encodeFieldUpdateCommand(e);case a.PUSH:case a.POP:case a.SHIFT:case a.UNSHIFT:return this.encodeArrayUpdateCommand(e);default:return this.encodeFieldUpdateCommand(e)}}encodeFieldUpdateCommand(e){const t=n(e.operator);switch(e.operator){case a.REMOVE:return{[t]:{[e.fieldName]:""}};case a.SET:case a.INC:case a.MUL:default:return{[t]:{[e.fieldName]:e.operands[0]}}}}encodeArrayUpdateCommand(e){const t=n(e.operator);switch(e.operator){case a.PUSH:{const a={$each:e.operands.map(c)};return{[t]:{[e.fieldName]:a}}}case a.UNSHIFT:{const a={$each:e.operands.map(c),$position:0};return{[t]:{[e.fieldName]:a}}}case a.POP:return{[t]:{[e.fieldName]:1}};case a.SHIFT:return{[t]:{[e.fieldName]:-1}};default:return{[t]:{[e.fieldName]:c(e.operands)}}}}encodeUpdateObject(o){const r=d(o);for(const o in r){if(/^\$/.test(o))continue;let n=r[o];if(t(n)){r[o]=n._setFieldName(o);const e=this.encodeUpdateCommand(r[o]);s(r,e,o)}else{r[o]=n=c(n);const t=new e(a.SET,[n],o),d=this.encodeUpdateCommand(t);s(r,d,o)}}return r}};