import e from"lodash/set";import t from"lodash/unset";import s from"lodash/cloneDeep";import{genRequestId as i}from"./message";import{CloudSDKError as r,isTimeoutError as n,CancelledError as o,isCancelledError as a}from"../utils/error";import{ERR_CODE as c}from"../config/error.config";import{sleep as h}from"../utils/utils";import{RealtimeListener as l}from"./listener";import{Snapshot as d}from"./snapshot";import{isRealtimeErrorMessageError as u}from"./error";var I;(function(e){e.LOGGINGIN="LOGGINGIN",e.INITING="INITING",e.REBUILDING="REBUILDING",e.ACTIVE="ACTIVE",e.ERRORED="ERRORED",e.CLOSING="CLOSING",e.CLOSED="CLOSED",e.PAUSED="PAUSED",e.RESUMING="RESUMING"})(I||(I={}));const E=100,m=2,_=2,v=1e4,S=1e4,f=1e4;export class VirtualWebSocketClient{constructor(e){this.watchStatus=I.INITING,this._login=(async(e,t)=>{this.watchStatus=I.LOGGINGIN;const s=await this.login(e,t);return this.envId||(this.envId=s.envId),s}),this.initWatch=(async e=>{if(this._initWatchPromise)return this._initWatchPromise;this._initWatchPromise=new Promise(async(t,s)=>{try{if(this.watchStatus===I.PAUSED)return console.log("[realtime] initWatch cancelled on pause"),t();const{envId:r}=await this._login(this.envId,e);if(this.watchStatus===I.PAUSED)return console.log("[realtime] initWatch cancelled on pause"),t();this.watchStatus=I.INITING;const n={watchId:this.watchId,requestId:i(),msgType:"INIT_WATCH",msgData:{envId:r,collName:this.collectionName,query:this.query}},o=await this.send({msg:n,waitResponse:!0,skipOnMessage:!0,timeout:S}),{events:a,currEvent:c}=o.msgData;if(this.sessionInfo={queryID:o.msgData.queryID,currentEventId:c-1,currentDocs:[]},a.length>0){for(const e of a)e.ID=c;this.handleServerEvents(o)}else{this.sessionInfo.currentEventId=c;const e=new d({id:c,docChanges:[],docs:[],type:"init"});this.listener.onChange(e),this.scheduleSendACK()}this.onWatchStart(this,this.sessionInfo.queryID),this.watchStatus=I.ACTIVE,this._availableRetries.INIT_WATCH=m,t()}catch(e){this.handleWatchEstablishmentError(e,{operationName:"INIT_WATCH",resolve:t,reject:s})}});let t=!1;try{await this._initWatchPromise,t=!0}finally{this._initWatchPromise=void 0}console.log(`[realtime] initWatch ${t?"success":"fail"}`)}),this.rebuildWatch=(async e=>{if(this._rebuildWatchPromise)return this._rebuildWatchPromise;this._rebuildWatchPromise=new Promise(async(t,s)=>{try{if(this.watchStatus===I.PAUSED)return console.log("[realtime] rebuildWatch cancelled on pause"),t();const{envId:r}=await this._login(this.envId,e);if(!this.sessionInfo)throw new Error("can not rebuildWatch without a successful initWatch (lack of sessionInfo)");if(this.watchStatus===I.PAUSED)return console.log("[realtime] rebuildWatch cancelled on pause"),t();this.watchStatus=I.REBUILDING;const n={watchId:this.watchId,requestId:i(),msgType:"REBUILD_WATCH",msgData:{envId:r,collName:this.collectionName,queryID:this.sessionInfo.queryID,eventID:this.sessionInfo.currentEventId}},o=await this.send({msg:n,waitResponse:!0,skipOnMessage:!1,timeout:f});this.handleServerEvents(o),this.watchStatus=I.ACTIVE,this._availableRetries.REBUILD_WATCH=m,t()}catch(e){this.handleWatchEstablishmentError(e,{operationName:"REBUILD_WATCH",resolve:t,reject:s})}});let t=!1;try{await this._rebuildWatchPromise,t=!0}finally{this._rebuildWatchPromise=void 0}console.log(`[realtime] rebuildWatch ${t?"success":"fail"}`)}),this.handleWatchEstablishmentError=(async(e,t)=>{const s="INIT_WATCH"===t.operationName,i=()=>{this.closeWithError(new r({errCode:s?c.SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL:c.SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL,errMsg:e})),t.reject(e)},n=e=>{this.useRetryTicket(t.operationName)?s?(this._initWatchPromise=void 0,t.resolve(this.initWatch(e))):(this._rebuildWatchPromise=void 0,t.resolve(this.rebuildWatch(e))):i()};this.handleCommonError(e,{onSignError:()=>n(!0),onTimeoutError:()=>n(!1),onNotRetryableError:i,onCancelledError:t.reject,onUnknownError:async()=>{try{const e=async()=>{this.pause(),await this.onceWSConnected(),n(!0)};this.isWSConnected()?(await h(E),this.watchStatus===I.PAUSED?t.reject(new o(`${t.operationName} cancelled due to pause after unknownError`)):this.isWSConnected()?n(!1):await e()):await e()}catch(e){n(!0)}}})}),this.closeWatch=(async()=>{const e=this.sessionInfo?this.sessionInfo.queryID:"";if(this.watchStatus!==I.ACTIVE)return this.watchStatus=I.CLOSED,this.onWatchClose(this,e),void 0;try{this.watchStatus=I.CLOSING;const t={watchId:this.watchId,requestId:i(),msgType:"CLOSE_WATCH",msgData:null};await this.send({msg:t}),this.sessionInfo=void 0,this.watchStatus=I.CLOSED}catch(e){this.closeWithError(new r({errCode:c.SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL,errMsg:e}))}finally{this.onWatchClose(this,e)}}),this.scheduleSendACK=(()=>{this.clearACKSchedule(),this._ackTimeoutId=setTimeout(()=>{this._waitExpectedTimeoutId?this.scheduleSendACK():this.sendACK()},v)}),this.clearACKSchedule=(()=>{this._ackTimeoutId&&clearTimeout(this._ackTimeoutId)}),this.sendACK=(async()=>{try{if(this.watchStatus!==I.ACTIVE)return this.scheduleSendACK(),void 0;if(!this.sessionInfo)return console.warn("[realtime listener] can not send ack without a successful initWatch (lack of sessionInfo)"),void 0;const e={watchId:this.watchId,requestId:i(),msgType:"CHECK_LAST",msgData:{queryID:this.sessionInfo.queryID,eventID:this.sessionInfo.currentEventId}};await this.send({msg:e}),this.scheduleSendACK()}catch(e){if(u(e)){const t=e.payload;switch(t.msgData.code){case"CHECK_LOGIN_FAILED":case"SIGN_EXPIRED_ERROR":case"SIGN_INVALID_ERROR":case"SIGN_PARAM_INVALID":return this.rebuildWatch(),void 0;case"QUERYID_INVALID_ERROR":case"SYS_ERR":case"INVALIID_ENV":case"COLLECTION_PERMISSION_DENIED":return this.closeWithError(new r({errCode:c.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,errMsg:t.msgData.code})),void 0}}this._availableRetries.CHECK_LAST&&this._availableRetries.CHECK_LAST>0?(this._availableRetries.CHECK_LAST--,this.scheduleSendACK()):this.closeWithError(new r({errCode:c.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,errMsg:e}))}}),this.handleCommonError=((e,t)=>{if(u(e)){switch(e.payload.msgData.code){case"CHECK_LOGIN_FAILED":case"SIGN_EXPIRED_ERROR":case"SIGN_INVALID_ERROR":case"SIGN_PARAM_INVALID":return t.onSignError(e),void 0;case"QUERYID_INVALID_ERROR":case"SYS_ERR":case"INVALIID_ENV":case"COLLECTION_PERMISSION_DENIED":default:return t.onNotRetryableError(e),void 0}}else{if(n(e))return t.onTimeoutError(e),void 0;if(a(e))return t.onCancelledError(e),void 0}t.onUnknownError(e)}),this.watchId=`watchid_${+new Date}_${Math.random()}`,this.envId=e.envId,this.collectionName=e.collectionName,this.query=e.query,this.send=e.send,this.login=e.login,this.isWSConnected=e.isWSConnected,this.onceWSConnected=e.onceWSConnected,this.getWaitExpectedTimeoutLength=e.getWaitExpectedTimeoutLength,this.onWatchStart=e.onWatchStart,this.onWatchClose=e.onWatchClose,this.debug=e.debug,this._availableRetries={INIT_WATCH:m,REBUILD_WATCH:m,CHECK_LAST:_},this.listener=new l({close:this.closeWatch,onChange:e.onChange,onError:e.onError,debug:this.debug,virtualClient:this}),this.initWatch()}useRetryTicket(e){return!!(this._availableRetries[e]&&this._availableRetries[e]>0)&&(this._availableRetries[e]--,console.log(`[realtime] ${e} use a retry ticket, now only ${this._availableRetries[e]} retry left`),!0)}async handleServerEvents(e){try{this.scheduleSendACK(),await this._handleServerEvents(e),this._postHandleServerEventsValidityCheck(e)}catch(e){throw console.error("[realtime listener] internal non-fatal error: handle server events failed with error: ",e),e}}async _handleServerEvents(i){const{requestId:n}=i,{events:o}=i.msgData,{msgType:a}=i;if(!o.length||!this.sessionInfo)return;const h=this.sessionInfo;let l;try{l=o.map(w)}catch(e){return this.closeWithError(new r({errCode:c.SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA,errMsg:e})),void 0}let u=[...h.currentDocs],I=!1;for(let o=0,E=l.length;o<E;o++){const m=l[o];if(h.currentEventId>=m.id)!l[o-1]||m.id>l[o-1].id?console.warn(`[realtime] duplicate event received, cur ${h.currentEventId} but got ${m.id}`):console.error(`[realtime listener] server non-fatal error: events out of order (the latter event's id is smaller than that of the former) (requestId ${n})`);else{if(h.currentEventId!==m.id-1)return console.warn(`[realtime listener] event received is out of order, cur ${this.sessionInfo.currentEventId} but got ${m.id}`),await this.rebuildWatch(),void 0;switch(m.dataType){case"update":if(!m.doc)switch(m.queueType){case"update":case"dequeue":{const i=u.find(e=>e._id===m.docId);if(i){const r=s(i);if(m.updatedFields)for(const t in m.updatedFields)e(r,t,m.updatedFields[t]);if(m.removedFields)for(const e of m.removedFields)t(r,e);m.doc=r}else console.error("[realtime listener] internal non-fatal server error: unexpected update dataType event where no doc is associated.");break}case"enqueue":{const e=new r({errCode:c.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,errMsg:`HandleServerEvents: full doc is not provided with dataType="update" and queueType="enqueue" (requestId ${i.requestId})`});throw this.closeWithError(e),e}}break;case"replace":if(!m.doc){const e=new r({errCode:c.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,errMsg:`HandleServerEvents: full doc is not provided with dataType="replace" (requestId ${i.requestId})`});throw this.closeWithError(e),e}break;case"remove":{const e=u.find(e=>e._id===m.docId);e?m.doc=e:console.error("[realtime listener] internal non-fatal server error: unexpected remove event where no doc is associated.");break}}switch(m.queueType){case"init":I?u.push(m.doc):(I=!0,u=[m.doc]);break;case"enqueue":u.push(m.doc);break;case"dequeue":{const e=u.findIndex(e=>e._id===m.docId);e>-1?u.splice(e,1):console.error("[realtime listener] internal non-fatal server error: unexpected dequeue event where no doc is associated.");break}case"update":{const e=u.findIndex(e=>e._id===m.docId);e>-1?u[e]=m.doc:console.error("[realtime listener] internal non-fatal server error: unexpected queueType update event where no doc is associated.");break}}if(o===E-1||l[o+1]&&l[o+1].id!==m.id){const e=[...u],t=l.slice(0,o+1).filter(e=>e.id===m.id);this.sessionInfo.currentEventId=m.id,this.sessionInfo.currentDocs=u;const s=new d({id:m.id,docChanges:t,docs:e,msgType:a});this.listener.onChange(s)}}}}_postHandleServerEventsValidityCheck(e){return this.sessionInfo?(this.sessionInfo.expectEventId&&this.sessionInfo.currentEventId>=this.sessionInfo.expectEventId&&this.clearWaitExpectedEvent(),this.sessionInfo.currentEventId<e.msgData.currEvent?(console.warn("[realtime listener] internal non-fatal error: client eventId does not match with server event id after server event handling"),void 0):void 0):(console.error("[realtime listener] internal non-fatal error: sessionInfo lost after server event handling, this should never occur"),void 0)}clearWaitExpectedEvent(){this._waitExpectedTimeoutId&&(clearTimeout(this._waitExpectedTimeoutId),this._waitExpectedTimeoutId=void 0)}onMessage(e){switch(this.watchStatus){case I.PAUSED:if("ERROR"!==e.msgType)return;break;case I.LOGGINGIN:case I.INITING:case I.REBUILDING:return console.warn(`[realtime listener] internal non-fatal error: unexpected message received while ${this.watchStatus}`),void 0;case I.CLOSED:return console.warn("[realtime listener] internal non-fatal error: unexpected message received when the watch has closed"),void 0;case I.ERRORED:return console.warn("[realtime listener] internal non-fatal error: unexpected message received when the watch has ended with error"),void 0}if(!this.sessionInfo)return console.warn("[realtime listener] internal non-fatal error: sessionInfo not found while message is received."),void 0;switch(this.scheduleSendACK(),e.msgType){case"NEXT_EVENT":console.warn(`nextevent ${e.msgData.currEvent} ignored`,e),this.handleServerEvents(e);break;case"CHECK_EVENT":this.sessionInfo.currentEventId<e.msgData.currEvent&&(this.sessionInfo.expectEventId=e.msgData.currEvent,this.clearWaitExpectedEvent(),this._waitExpectedTimeoutId=setTimeout(()=>{this.rebuildWatch()},this.getWaitExpectedTimeoutLength()),console.log(`[realtime] waitExpectedTimeoutLength ${this.getWaitExpectedTimeoutLength()}`));break;case"ERROR":this.closeWithError(new r({errCode:c.SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG,errMsg:`${e.msgData.code} - ${e.msgData.message}`}));break;default:console.warn(`[realtime listener] virtual client receive unexpected msg ${e.msgType}: `,e)}}closeWithError(e){this.watchStatus=I.ERRORED,this.clearACKSchedule(),this.listener.onError(e),this.onWatchClose(this,this.sessionInfo&&this.sessionInfo.queryID||""),console.log(`[realtime] client closed (${this.collectionName} ${this.query}) (watchId ${this.watchId})`)}pause(){this.watchStatus=I.PAUSED,console.log(`[realtime] client paused (${this.collectionName} ${this.query}) (watchId ${this.watchId})`)}async resume(){this.watchStatus=I.RESUMING,console.log(`[realtime] client resuming with ${this.sessionInfo?"REBUILD_WATCH":"INIT_WATCH"} (${this.collectionName} ${this.query}) (${this.watchId})`);try{await(this.sessionInfo?this.rebuildWatch():this.initWatch()),console.log(`[realtime] client successfully resumed (${this.collectionName} ${this.query}) (${this.watchId})`)}catch(e){console.error(`[realtime] client resume failed (${this.collectionName} ${this.query}) (${this.watchId})`,e)}}};function w(e){const t={id:e.ID,dataType:e.DataType,queueType:e.QueueType,docId:e.DocID,doc:e.Doc&&"{}"!==e.Doc?JSON.parse(e.Doc):void 0};return"update"===e.DataType&&(e.UpdatedFields&&(t.updatedFields=JSON.parse(e.UpdatedFields)),(e.removedFields||e.RemovedFields)&&(t.removedFields=JSON.parse(e.removedFields))),t}