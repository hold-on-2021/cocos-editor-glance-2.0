import{SYMBOL_GEO_MULTI_POLYGON as t}from"../helper/symbol";import{isArray as e,isNumber as o}from"../utils/type";import{LineString as r}from"./lineString";export class Polygon{constructor(t){if(!e(t))throw new TypeError(`"lines" must be of type LineString[]. Received type ${typeof t}`);if(0===t.length)throw new Error("Polygon must contain 1 linestring at least");t.forEach(t=>{if(!(t instanceof r))throw new TypeError(`"lines" must be of type LineString[]. Received type ${typeof t}[]`);if(!r.isClosed(t))throw new Error(`LineString ${t.points.map(t=>t.toReadableString())} is not a closed cycle`)}),this.lines=t}parse(t){return{[t]:{type:"Polygon",coordinates:this.lines.map(t=>t.points.map(t=>[t.longitude,t.latitude]))}}}toJSON(){return{type:"Polygon",coordinates:this.lines.map(t=>t.points.map(t=>[t.longitude,t.latitude]))}}static validate(t){if("Polygon"!==t.type||!e(t.coordinates))return!1;for(let e of t.coordinates){if(!this.isCloseLineString(e))return!1;for(let t of e)if(!o(t[0])||!o(t[1]))return!1}return!0}static isCloseLineString(t){const e=t[0],o=t[t.length-1];return e[0]===o[0]&&e[1]===o[1]}get _internalType(){return t}};