import{LogicCommand as e}from"./logic";import{SYMBOL_QUERY_COMMAND as t}from"../helper/symbol";import{Point as n,LineString as o,Polygon as r,MultiPoint as i,MultiLineString as m,MultiPolygon as s}from"../geo/index";import{isNumber as a}from"../utils/type";export const EQ="eq";export const NEQ="neq";export const GT="gt";export const GTE="gte";export const LT="lt";export const LTE="lte";export const IN="in";export const NIN="nin";export var QUERY_COMMANDS_LITERAL;(function(e){e.EQ="eq",e.NEQ="neq",e.GT="gt",e.GTE="gte",e.LT="lt",e.LTE="lte",e.IN="in",e.NIN="nin",e.GEO_NEAR="geoNear",e.GEO_WITHIN="geoWithin",e.GEO_INTERSECTS="geoIntersects"})(QUERY_COMMANDS_LITERAL||(QUERY_COMMANDS_LITERAL={}));export class QueryCommand extends e{constructor(e,n,o){super(e,n,o),this.operator=e,this._internalType=t}_setFieldName(e){return new QueryCommand(this.operator,this.operands,e)}eq(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.EQ,[e],this.fieldName);return this.and(t)}neq(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.NEQ,[e],this.fieldName);return this.and(t)}gt(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.GT,[e],this.fieldName);return this.and(t)}gte(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.GTE,[e],this.fieldName);return this.and(t)}lt(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.LT,[e],this.fieldName);return this.and(t)}lte(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.LTE,[e],this.fieldName);return this.and(t)}in(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.IN,e,this.fieldName);return this.and(t)}nin(e){const t=new QueryCommand(QUERY_COMMANDS_LITERAL.NIN,e,this.fieldName);return this.and(t)}geoNear(e){if(!(e.geometry instanceof n))throw new TypeError(`"geometry" must be of type Point. Received type ${typeof e.geometry}`);if(void 0!==e.maxDistance&&!a(e.maxDistance))throw new TypeError(`"maxDistance" must be of type Number. Received type ${typeof e.maxDistance}`);if(void 0!==e.minDistance&&!a(e.minDistance))throw new TypeError(`"minDistance" must be of type Number. Received type ${typeof e.minDistance}`);const t=new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_NEAR,[e],this.fieldName);return this.and(t)}geoWithin(e){if(!(e.geometry instanceof s||e.geometry instanceof r))throw new TypeError(`"geometry" must be of type Polygon or MultiPolygon. Received type ${typeof e.geometry}`);const t=new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_WITHIN,[e],this.fieldName);return this.and(t)}geoIntersects(e){if(!(e.geometry instanceof n||e.geometry instanceof o||e.geometry instanceof r||e.geometry instanceof i||e.geometry instanceof m||e.geometry instanceof s))throw new TypeError(`"geometry" must be of type Point, LineString, Polygon, MultiPoint, MultiLineString or MultiPolygon. Received type ${typeof e.geometry}`);const t=new QueryCommand(QUERY_COMMANDS_LITERAL.GEO_INTERSECTS,[e],this.fieldName);return this.and(t)}};export function isQueryCommand(e){return e&&e instanceof QueryCommand&&e._internalType===t};export function isKnownQueryCommand(e){return isQueryCommand(e)&&e.operator.toUpperCase()in QUERY_COMMANDS_LITERAL};export function isComparisonCommand(e){return isQueryCommand(e)};export default QueryCommand;