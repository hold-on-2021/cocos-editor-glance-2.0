import{getType as e,isObject as t,isArray as n,isDate as o,isRegExp as r,isInternalObject as i}from"../utils/type";import{serialize as c,deserialize as s}from"./datatype";function u(e,n,o,r){const i=Object.assign({},e);for(const c in e){if(/^\$/.test(c))continue;const s=e[c];if(s&&(t(s)&&!n(s))){if(r.indexOf(s)>-1)throw new Error("Cannot convert circular structure to JSON");const e=u(s,n,[...o,c],[...r,s]);i[c]=e;let t=!1;for(const n in e)/^\$/.test(n)?t=!0:(i[`${c}.${n}`]=e[n],delete i[c][n]);t||delete i[c]}}return i}export function flattenQueryObject(e){return u(e,isConversionRequired,[],[e])};export function flattenObject(e){return u(e,e=>!1,[],[e])};export function mergeConditionAfterEncode(o,r,i){r[i]||delete o[i];for(const c in r)o[c]?n(o[c])?o[c].push(r[c]):t(o[c])?t(r[c])?Object.assign(o[c],r[c]):(console.warn(`unmergable condition, query is object but condition is ${e(r)}, can only overwrite`,r,i),o[c]=r[c]):(console.warn(`to-merge query is of type ${e(o)}, can only overwrite`,o,r,i),o[c]=r[c]):o[c]=r[c]};export function isConversionRequired(e){return i(e)||o(e)||r(e)};export function encodeInternalDataType(e){return c(e)};export function decodeInternalDataType(e){return s(e)};