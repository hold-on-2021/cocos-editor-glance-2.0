import{QueryCommand as e,QUERY_COMMANDS_LITERAL as r}from"./commands/query";import{LogicCommand as t,LOGIC_COMMANDS_LITERAL as n}from"./commands/logic";import{UpdateCommand as o,UPDATE_COMMANDS_LITERAL as a}from"./commands/update";import{isArray as s}from"./utils/type";export const Command={eq:t=>new e(r.EQ,[t]),neq:t=>new e(r.NEQ,[t]),lt:t=>new e(r.LT,[t]),lte:t=>new e(r.LTE,[t]),gt:t=>new e(r.GT,[t]),gte:t=>new e(r.GTE,[t]),in:t=>new e(r.IN,t),nin:t=>new e(r.NIN,t),geoNear:t=>new e(r.GEO_NEAR,[t]),geoWithin:t=>new e(r.GEO_WITHIN,[t]),geoIntersects:t=>new e(r.GEO_INTERSECTS,[t]),and(...e){const r=s(arguments[0])?arguments[0]:Array.from(arguments);return new t(n.AND,r)},nor(...e){const r=s(arguments[0])?arguments[0]:Array.from(arguments);return new t(n.NOR,r)},or(...e){const r=s(arguments[0])?arguments[0]:Array.from(arguments);return new t(n.OR,r)},set:e=>new o(a.SET,[e]),remove:()=>new o(a.REMOVE,[]),inc:e=>new o(a.INC,[e]),mul:e=>new o(a.MUL,[e]),push(...e){const r=s(arguments[0])?arguments[0]:Array.from(arguments);return new o(a.PUSH,r)},pop:()=>new o(a.POP,[]),shift:()=>new o(a.SHIFT,[]),unshift(...e){const r=s(arguments[0])?arguments[0]:Array.from(arguments);return new o(a.UNSHIFT,r)},aggregate:{},project:{}};["abs","add","ceil","divide","exp","floor","ln","log","log10","mod","multiply","pow","sqrt","subtract","trunc","arrayElemAt","arrayToObject","concatArrays","filter","in","indexOfArray","isArray","map","objectToArray","range","reduce","reverseArray","size","slice","zip","and","not","or","cmp","eq","gt","gte","lt","lte","ne","cond","ifNull","switch","dayOfWeek","dateFromParts","dateFromString","dayOfMonth","dayOfWeek","dayOfYear","isoDayOfWeek","isoWeek","isoWeekYear","millisecond","minute","month","second","hour","week","year","literal","mergeObjects","objectToArray","allElementsTrue","anyElementTrue","setDifference","setEquals","setIntersection","setIsSubset","setUnion","concat","dateToString","indexOfBytes","indexOfCP","split","strLenBytes","strLenCP","strcasecmp","substr","substrBytes","substrCP","toLower","toUpper","meta","addToSet","avg","first","last","max","min","push","stdDevPop","stdDevSamp","sum","let"].forEach(e=>{let r=e;"ne"===e&&(r="neq"),Command.aggregate[r]=function(r){return{[`$${e}`]:r}}});["slice","elemMatch"].forEach(e=>{let r=e;Command.project[r]=function(r){return{[`$${e}`]:r}}});export default Command;