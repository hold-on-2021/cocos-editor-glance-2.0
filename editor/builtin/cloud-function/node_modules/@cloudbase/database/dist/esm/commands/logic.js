import{SYMBOL_UNSET_FIELD_NAME as o,SYMBOL_LOGIC_COMMAND as e}from"../helper/symbol";import{isQueryCommand as r}from"./query";export const AND="and";export const OR="or";export const NOT="not";export const NOR="nor";export var LOGIC_COMMANDS_LITERAL;(function(o){o.AND="and",o.OR="or",o.NOT="not",o.NOR="nor"})(LOGIC_COMMANDS_LITERAL||(LOGIC_COMMANDS_LITERAL={}));export class LogicCommand{constructor(t,n,i){if(this._internalType=e,Object.defineProperties(this,{_internalType:{enumerable:!1,configurable:!1}}),this.operator=t,this.operands=n,this.fieldName=i||o,this.fieldName!==o){n=n.slice(),this.operands=n;for(let o=0,e=n.length;o<e;o++){const e=n[o];(isLogicCommand(e)||r(e))&&(n[o]=e._setFieldName(this.fieldName))}}}_setFieldName(o){const e=this.operands.map(e=>e instanceof LogicCommand?e._setFieldName(o):e);return new LogicCommand(this.operator,e,o)}and(...o){const e=Array.isArray(arguments[0])?arguments[0]:Array.from(arguments);return e.unshift(this),new LogicCommand(LOGIC_COMMANDS_LITERAL.AND,e,this.fieldName)}or(...o){const e=Array.isArray(arguments[0])?arguments[0]:Array.from(arguments);return e.unshift(this),new LogicCommand(LOGIC_COMMANDS_LITERAL.OR,e,this.fieldName)}};export function isLogicCommand(o){return o&&o instanceof LogicCommand&&o._internalType===e};export function isKnownLogicCommand(o){return isLogicCommand&&o.operator.toUpperCase()in LOGIC_COMMANDS_LITERAL};export default LogicCommand;