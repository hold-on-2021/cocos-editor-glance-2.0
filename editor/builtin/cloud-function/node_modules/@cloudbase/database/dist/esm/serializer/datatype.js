import{SYMBOL_GEO_POINT as r,SYMBOL_SERVER_DATE as e,SYMBOL_REGEXP as t}from"../helper/symbol";import{getType as n,isObject as o,isArray as i,isDate as c,isNumber as s,isInternalObject as a,isRegExp as u}from"../utils/type";import{Point as f}from"../geo/index";import{ServerDate as p}from"../serverDate/index";export function serialize(n){return function n(s,f){if(!a(s)){if(c(s))return{$date:+s};if(u(s))return{$regex:s.source,$options:s.flags};if(i(s))return s.map(r=>{if(f.indexOf(r)>-1)throw new Error("Cannot convert circular structure to JSON");return n(r,[...f,r])});if(o(s)){const r=Object.assign({},s);for(const e in r){if(f.indexOf(r[e])>-1)throw new Error("Cannot convert circular structure to JSON");r[e]=n(r[e],[...f,r[e]])}return r}return s}switch(s._internalType){case r:return s.toJSON();case e:case t:return s.parse();default:return s.toJSON?s.toJSON():s}}(n,[n])};export function deserialize(r){const e=Object.assign({},r);for(const r in e)switch(r){case"$date":switch(n(e[r])){case"number":return new Date(e[r]);case"object":return new p(e[r])}break;case"type":switch(e.type){case"Point":if(i(e.coordinates)&&s(e.coordinates[0])&&s(e.coordinates[1]))return new f(e.coordinates[0],e.coordinates[1])}}return r};