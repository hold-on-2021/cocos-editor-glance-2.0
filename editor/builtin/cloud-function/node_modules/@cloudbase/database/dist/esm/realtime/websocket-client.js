import{VirtualWebSocketClient as e}from"./virtual-websocket-client";import{sleep as t}from"../utils/utils";import{genRequestId as s}from"./message";import{CLOSE_EVENT_CODE as i,CLOSE_EVENT_CODE_INFO as n,getWSCloseError as o}from"./ws-event";import{CloudSDKError as r,TimeoutError as a}from"../utils/error";import{RealtimeErrorMessageError as c}from"./error";import{ERR_CODE as l}from"../config/error.config";const h={CONNECTING:0,OPEN:1,CLOSING:2,CLOSED:3},g=3,d=5e3,w=1e4,m=5,_=1e4,u=2,S=2,p=5e3;export class RealtimeWebSocketClient{constructor(e){this._virtualWSClient=new Set,this._queryIdClientMap=new Map,this._watchIdClientMap=new Map,this._pingFailed=0,this._pongMissed=0,this._logins=new Map,this._wsReadySubsribers=[],this._wsResponseWait=new Map,this._rttObserved=[],this.initWebSocketConnection=(async(e,s=this._maxReconnect)=>{if(e&&this._reconnectState)return;if(e&&(this._reconnectState=!0),this._wsInitPromise)return this._wsInitPromise;console.log(`[realtime] initWebSocketConnection reconnect ${e} availableRetries ${s}`),e&&this.pauseClients(),this.close(i.ReconnectWebSocket),this._wsInitPromise=new Promise(async(i,n)=>{try{console.log("[realtime] initWebSocketConnection start throwErrorIfNetworkOffline"),console.log("[realtime] initWebSocketConnection start getSignature"),await this.getAccessToken(),console.log("[realtime] initWebSocketConnection getSignature success"),console.log("[realtime] initWebSocketConnection start connectSocket"),await new Promise(e=>{this._ws=new WebSocket("wss://tcb-ws.tencentcloudapi.com"),e()}),console.log("[realtime] initWebSocketConnection connectSocket successfully fired"),await this.initWebSocketEvent(),i(),e&&(this.resumeClients(),this._reconnectState=!1)}catch(o){if(console.error("[realtime] initWebSocketConnection connect fail",o),s>0){const n=!0;console.log("[realtime] initWebSocketConnection waiting for network online"),console.log("[realtime] initWebSocketConnection network online"),this._wsInitPromise=void 0,n&&(console.log(`[realtime] initWebSocketConnection sleep ${this._reconnectInterval}ms`),await t(this._reconnectInterval),e&&(this._reconnectState=!1)),i(this.initWebSocketConnection(e,s-1))}else n(o),e&&this.closeAllClients(new r({errCode:l.SDK_DATABASE_REALTIME_LISTENER_RECONNECT_WATCH_FAIL,errMsg:o}))}});let n=!1;try{await this._wsInitPromise,n=!0,this._wsReadySubsribers.forEach(({resolve:e})=>e())}catch(e){this._wsReadySubsribers.forEach(({reject:e})=>e())}finally{this._wsInitPromise=void 0,this._wsReadySubsribers=[]}console.log(`[realtime] initWebSocketConnection ${n?"success":"fail"}`)}),this.initWebSocketEvent=(()=>new Promise((e,t)=>{if(!this._ws)throw new Error("can not initWebSocketEvent, ws not exists");let s=!1;this._ws.onopen=(t=>{console.warn("[realtime] ws event: open",t),s=!0,e()}),this._ws.onerror=(e=>{this._logins=new Map,s?(console.error("[realtime] ws event: error",e),this.clearHeartbeat(),this._virtualWSClient.forEach(t=>t.closeWithError(new r({errCode:l.SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_ERROR,errMsg:e})))):(console.error("[realtime] ws open failed with ws event: error",e),t(e))}),this._ws.onclose=(e=>{switch(console.warn("[realtime] ws event: close",e),this._logins=new Map,this.clearHeartbeat(),e.code){case i.ReconnectWebSocket:case i.NoRealtimeListeners:break;case i.HeartbeatPingError:case i.HeartbeatPongTimeoutError:case i.NormalClosure:case i.AbnormalClosure:this._maxReconnect>0?this.initWebSocketConnection(!0,this._maxReconnect):this.closeAllClients(o(e.code));break;case i.NoAuthentication:this.closeAllClients(o(e.code,e.reason));break;default:this._maxReconnect>0?this.initWebSocketConnection(!0,this._maxReconnect):this.closeAllClients(o(e.code))}}),this._ws.onmessage=(e=>{const t=e.data;let s;this.heartbeat();try{s=JSON.parse(t)}catch(e){throw new Error(`[realtime] onMessage parse res.data error: ${e}`)}if(console.log(`[realtime] onMessage ${s.msgType} (${(new Date).toLocaleString()})`,s),"ERROR"===s.msgType){let e=null;this._virtualWSClient.forEach(t=>{t.watchId===s.watchId&&(e=t)}),e&&e.listener.onError(s)}const i=this._wsResponseWait.get(s.requestId);if(i){try{"ERROR"===s.msgType?i.reject(new c(s)):i.resolve(s)}catch(e){console.error("ws onMessage responseWaitSpec.resolve(msg) errored:",e)}finally{this._wsResponseWait.delete(s.requestId)}if(i.skipOnMessage)return}if("PONG"===s.msgType){if(this._lastPingSendTS){const e=Date.now()-this._lastPingSendTS;if(e>w)return console.warn(`[realtime] untrusted rtt observed: ${e}`),void 0;this._rttObserved.length>=g&&this._rttObserved.splice(0,this._rttObserved.length-g+1),this._rttObserved.push(e)}return}let n=s.watchId&&this._watchIdClientMap.get(s.watchId);if(n)n.onMessage(s);else switch(console.error(`[realtime] no realtime listener found responsible for watchId ${s.watchId}: `,s),s.msgType){case"INIT_EVENT":case"NEXT_EVENT":case"CHECK_EVENT":(n=this._queryIdClientMap.get(s.msgData.queryID))&&n.onMessage(s);break;default:for(const[e,t]of this._watchIdClientMap){console.log("watchid*****",e),t.onMessage(s);break}}}),this.heartbeat()})),this.isWSConnected=(()=>Boolean(this._ws&&this._ws.readyState===h.OPEN)),this.onceWSConnected=(async()=>{if(!this.isWSConnected())return this._wsInitPromise?this._wsInitPromise:new Promise((e,t)=>{this._wsReadySubsribers.push({resolve:e,reject:t})})}),this.webLogin=(async(e,t)=>{if(!t)if(e){const t=this._logins.get(e);if(t){if(t.loggedIn&&t.loginResult)return console.log("[realtime] login: already logged in"),t.loginResult;if(t.loggingInPromise)return t.loggingInPromise}}else{const e=this._logins.get("");if(e&&e.loggingInPromise)return e.loggingInPromise}console.log("[realtime] login: logging in");const i=new Promise(async(e,t)=>{try{const i=await this.getAccessToken(),n={watchId:void 0,requestId:s(),msgType:"LOGIN",msgData:{envId:i.env||"",accessToken:i.accessToken,referrer:"web",sdkVersion:"",dataVersion:""}},o=await this.send({msg:n,waitResponse:!0,skipOnMessage:!0,timeout:p});o.msgData.code?t(new Error(`${o.msgData.code} ${o.msgData.message}`)):e({envId:i.env})}catch(e){t(e)}});let n=e&&this._logins.get(e);const o=Date.now();n?(n.loggedIn=!1,n.loggingInPromise=i,n.loginStartTS=o):(n={loggedIn:!1,loggingInPromise:i,loginStartTS:o},this._logins.set(e||"",n));try{const t=await i,s=e&&this._logins.get(e);if(s&&s===n&&s.loginStartTS===o)return n.loggedIn=!0,n.loggingInPromise=void 0,n.loginStartTS=void 0,n.loginResult=t,t;if(s){if(s.loggedIn&&s.loginResult)return s.loginResult;if(s.loggingInPromise)return s.loggingInPromise;throw new Error("ws unexpected login info")}throw new Error("ws login info reset")}catch(e){throw n.loggedIn=!1,n.loggingInPromise=void 0,n.loginStartTS=void 0,n.loginResult=void 0,e}}),this.getAccessToken=(async()=>this._context.appConfig.getAccessToken()),this.getWaitExpectedTimeoutLength=(()=>this._rttObserved.length?this._rttObserved.reduce((e,t)=>e+t)/this._rttObserved.length*1.5:d),this.ping=(async()=>{const e={watchId:void 0,requestId:s(),msgType:"PING",msgData:null};await this.send({msg:e}),console.log("ping sent")}),this.send=(e=>new Promise(async(s,i)=>{let n,o=!1,r=!1;const c=e=>{o=!0,n&&clearTimeout(n),s(e)},l=e=>{r=!0,n&&clearTimeout(n),i(e)};e.timeout&&(n=setTimeout(async()=>{o&&r||(await t(0),o&&r||l(new a("wsclient.send timedout")))},e.timeout));try{if(console.log(`[realtime] ws send ${e.msg.msgType} (${(new Date).toLocaleString()}): `,e),this._wsInitPromise&&await this._wsInitPromise,!this._ws)return l(new Error("invalid state: ws connection not exists, can not send message")),void 0;if(this._ws.readyState!==h.OPEN)return l(new Error(`ws readyState invalid: ${this._ws.readyState}, can not send message`)),void 0;e.waitResponse&&this._wsResponseWait.set(e.msg.requestId,{resolve:c,reject:l,skipOnMessage:e.skipOnMessage}),console.log("send msg:",e.msg);try{this._ws.send(JSON.stringify(e.msg)),e.waitResponse||c()}catch(t){t&&(l(t),e.waitResponse&&this._wsResponseWait.delete(e.msg.requestId))}}catch(e){l(e)}})),this.closeAllClients=(e=>{this._virtualWSClient.forEach(t=>{t.closeWithError(e)})}),this.pauseClients=(e=>{(e||this._virtualWSClient).forEach(e=>{e.pause()})}),this.resumeClients=(e=>{(e||this._virtualWSClient).forEach(e=>{e.resume()})}),this.onWatchStart=((e,t)=>{this._queryIdClientMap.set(t,e)}),this.onWatchClose=((e,t)=>{t&&this._queryIdClientMap.delete(t),this._watchIdClientMap.delete(e.watchId),this._virtualWSClient.delete(e),this._virtualWSClient.size||this.close(i.NoRealtimeListeners)}),this._maxReconnect=e.maxReconnect||m,this._reconnectInterval=e.reconnectInterval||_,this._context=e.context}heartbeat(e){this.clearHeartbeat(),this._pingTimeoutId=setTimeout(async()=>{try{if(!this._ws||this._ws.readyState!==h.OPEN)return;this._lastPingSendTS=Date.now(),await this.ping(),this._pingFailed=0,this._pongTimeoutId=setTimeout(()=>{console.error("pong timed out"),this._pongMissed<S?(this._pongMissed++,this.heartbeat(!0)):this.initWebSocketConnection(!0)},this._context.appConfig.realtimePongWaitTimeout)}catch(e){this._pingFailed<u?(this._pingFailed++,this.heartbeat()):this.close(i.HeartbeatPingError)}},e?0:this._context.appConfig.realtimePingInterval)}clearHeartbeat(){this._pingTimeoutId&&clearTimeout(this._pingTimeoutId),this._pongTimeoutId&&clearTimeout(this._pongTimeoutId)}close(e){this.clearHeartbeat(),this._ws&&(this._ws.close(e,n[e].name),this._ws=void 0)}watch(t){this._ws||this._wsInitPromise||this.initWebSocketConnection(!1);const s=new e(Object.assign(Object.assign({},t),{send:this.send,login:this.webLogin,isWSConnected:this.isWSConnected,onceWSConnected:this.onceWSConnected,getWaitExpectedTimeoutLength:this.getWaitExpectedTimeoutLength,onWatchStart:this.onWatchStart,onWatchClose:this.onWatchClose,debug:!0}));return this._virtualWSClient.add(s),this._watchIdClientMap.set(s.watchId,s),s.listener}};