import{FieldType as e}from"./constant";import{Point as t,LineString as a,Polygon as r,MultiPoint as o,MultiLineString as i,MultiPolygon as n}from"./geo/index";import{ServerDate as l}from"./serverDate/index";export class Util{};Util.formatResDocumentData=(e=>e.map(e=>Util.formatField(e))),Util.formatField=(l=>{const c=Object.keys(l);let s={};return Array.isArray(l)&&(s=[]),c.forEach(c=>{const m=l[c];let d;switch(Util.whichType(m)){case e.GeoPoint:d=new t(m.coordinates[0],m.coordinates[1]);break;case e.GeoLineString:d=new a(m.coordinates.map(e=>new t(e[0],e[1])));break;case e.GeoPolygon:d=new r(m.coordinates.map(e=>new a(e.map(([e,a])=>new t(e,a)))));break;case e.GeoMultiPoint:d=new o(m.coordinates.map(e=>new t(e[0],e[1])));break;case e.GeoMultiLineString:d=new i(m.coordinates.map(e=>new a(e.map(([e,a])=>new t(e,a)))));break;case e.GeoMultiPolygon:d=new n(m.coordinates.map(e=>new r(e.map(e=>new a(e.map(([e,a])=>new t(e,a)))))));break;case e.Timestamp:d=new Date(1e3*m.$timestamp);break;case e.Object:case e.Array:d=Util.formatField(m);break;case e.ServerDate:d=new Date(m.$date);break;default:d=m}Array.isArray(s)?s.push(d):s[c]=d}),s}),Util.whichType=(c=>{let s=Object.prototype.toString.call(c).slice(8,-1);if(s===e.Object){if(c instanceof t)return e.GeoPoint;if(c instanceof Date)return e.Timestamp;if(c instanceof l)return e.ServerDate;c.$timestamp?s=e.Timestamp:c.$date?s=e.ServerDate:t.validate(c)?s=e.GeoPoint:a.validate(c)?s=e.GeoLineString:r.validate(c)?s=e.GeoPolygon:o.validate(c)?s=e.GeoMultiPoint:i.validate(c)?s=e.GeoMultiLineString:n.validate(c)&&(s=e.GeoMultiPolygon)}return s}),Util.generateDocId=(()=>{let e="ABCDEFabcdef0123456789",t="";for(let a=0;a<24;a++)t+=e.charAt(Math.floor(Math.random()*e.length));return t});