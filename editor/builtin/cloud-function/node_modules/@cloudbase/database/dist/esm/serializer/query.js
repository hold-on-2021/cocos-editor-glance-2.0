import{isQueryCommand as e,isComparisonCommand as o,QUERY_COMMANDS_LITERAL as r}from"../commands/query";import{isLogicCommand as n,LOGIC_COMMANDS_LITERAL as t}from"../commands/logic";import{SYMBOL_UNSET_FIELD_NAME as s}from"../helper/symbol";import{getType as a,isObject as c,isArray as i}from"../utils/type";import{operatorToString as m}from"../operator-map";import{flattenQueryObject as d,isConversionRequired as p,encodeInternalDataType as u}from"./common";export class QuerySerializer{constructor(){}static encode(e){return(new l).encodeQuery(e)}};class l{encodeQuery(o,r){return p(o)?n(o)?this.encodeLogicCommand(o):e(o)?this.encodeQueryCommand(o):{[r]:this.encodeQueryObject(o)}:c(o)?this.encodeQueryObject(o):o}encodeLogicCommand(e){switch(e.operator){case t.NOR:case t.AND:case t.OR:return{[m(e.operator)]:e.operands.map(o=>this.encodeQuery(o,e.fieldName))};default:{const o=m(e.operator);if(1===e.operands.length){return{[o]:this.encodeQuery(e.operands[0])}}return{[o]:e.operands.map(this.encodeQuery.bind(this))}}}}encodeQueryCommand(e){return o(e),this.encodeComparisonCommand(e)}encodeComparisonCommand(e){if(e.fieldName===s)throw new Error("Cannot encode a comparison command with unset field name");const o=m(e.operator);switch(e.operator){case r.EQ:case r.NEQ:case r.LT:case r.LTE:case r.GT:case r.GTE:return{[e.fieldName]:{[o]:u(e.operands[0])}};case r.IN:case r.NIN:return{[e.fieldName]:{[o]:u(e.operands)}};case r.GEO_NEAR:{const o=e.operands[0];return{[e.fieldName]:{$nearSphere:{$geometry:o.geometry.toJSON(),$maxDistance:o.maxDistance,$minDistance:o.minDistance}}}}case r.GEO_WITHIN:{const o=e.operands[0];return{[e.fieldName]:{$geoWithin:{$geometry:o.geometry.toJSON()}}}}case r.GEO_INTERSECTS:{const o=e.operands[0];return{[e.fieldName]:{$geoIntersects:{$geometry:o.geometry.toJSON()}}}}default:return{[e.fieldName]:{[o]:u(e.operands[0])}}}}encodeQueryObject(e){const r=d(e);for(const e in r){const t=r[e];if(n(t)){r[e]=t._setFieldName(e);const o=this.encodeLogicCommand(r[e]);this.mergeConditionAfterEncode(r,o,e)}else if(o(t)){r[e]=t._setFieldName(e);const o=this.encodeComparisonCommand(r[e]);this.mergeConditionAfterEncode(r,o,e)}else p(t)&&(r[e]=u(t))}return r}mergeConditionAfterEncode(e,o,r){o[r]||delete e[r];for(const n in o)e[n]?i(e[n])?e[n]=e[n].concat(o[n]):c(e[n])?c(o[n])?Object.assign(e,o):(console.warn(`unmergable condition, query is object but condition is ${a(o)}, can only overwrite`,o,r),e[n]=o[n]):(console.warn(`to-merge query is of type ${a(e)}, can only overwrite`,e,o,r),e[n]=o[n]):e[n]=o[n]}}