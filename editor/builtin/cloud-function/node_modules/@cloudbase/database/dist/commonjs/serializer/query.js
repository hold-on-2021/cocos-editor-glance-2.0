"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=require("../commands/query"),o=require("../commands/logic"),n=require("../helper/symbol"),r=require("../utils/type"),t=require("../operator-map"),a=require("./common");exports.QuerySerializer=class{constructor(){}static encode(e){return(new s).encodeQuery(e)}};class s{encodeQuery(n,t){return a.isConversionRequired(n)?o.isLogicCommand(n)?this.encodeLogicCommand(n):e.isQueryCommand(n)?this.encodeQueryCommand(n):{[t]:this.encodeQueryObject(n)}:r.isObject(n)?this.encodeQueryObject(n):n}encodeLogicCommand(e){switch(e.operator){case o.LOGIC_COMMANDS_LITERAL.NOR:case o.LOGIC_COMMANDS_LITERAL.AND:case o.LOGIC_COMMANDS_LITERAL.OR:return{[t.operatorToString(e.operator)]:e.operands.map(o=>this.encodeQuery(o,e.fieldName))};default:{const o=t.operatorToString(e.operator);if(1===e.operands.length){return{[o]:this.encodeQuery(e.operands[0])}}return{[o]:e.operands.map(this.encodeQuery.bind(this))}}}}encodeQueryCommand(o){return e.isComparisonCommand(o),this.encodeComparisonCommand(o)}encodeComparisonCommand(o){if(o.fieldName===n.SYMBOL_UNSET_FIELD_NAME)throw new Error("Cannot encode a comparison command with unset field name");const r=t.operatorToString(o.operator);switch(o.operator){case e.QUERY_COMMANDS_LITERAL.EQ:case e.QUERY_COMMANDS_LITERAL.NEQ:case e.QUERY_COMMANDS_LITERAL.LT:case e.QUERY_COMMANDS_LITERAL.LTE:case e.QUERY_COMMANDS_LITERAL.GT:case e.QUERY_COMMANDS_LITERAL.GTE:return{[o.fieldName]:{[r]:a.encodeInternalDataType(o.operands[0])}};case e.QUERY_COMMANDS_LITERAL.IN:case e.QUERY_COMMANDS_LITERAL.NIN:return{[o.fieldName]:{[r]:a.encodeInternalDataType(o.operands)}};case e.QUERY_COMMANDS_LITERAL.GEO_NEAR:{const e=o.operands[0];return{[o.fieldName]:{$nearSphere:{$geometry:e.geometry.toJSON(),$maxDistance:e.maxDistance,$minDistance:e.minDistance}}}}case e.QUERY_COMMANDS_LITERAL.GEO_WITHIN:{const e=o.operands[0];return{[o.fieldName]:{$geoWithin:{$geometry:e.geometry.toJSON()}}}}case e.QUERY_COMMANDS_LITERAL.GEO_INTERSECTS:{const e=o.operands[0];return{[o.fieldName]:{$geoIntersects:{$geometry:e.geometry.toJSON()}}}}default:return{[o.fieldName]:{[r]:a.encodeInternalDataType(o.operands[0])}}}}encodeQueryObject(n){const r=a.flattenQueryObject(n);for(const n in r){const t=r[n];if(o.isLogicCommand(t)){r[n]=t._setFieldName(n);const e=this.encodeLogicCommand(r[n]);this.mergeConditionAfterEncode(r,e,n)}else if(e.isComparisonCommand(t)){r[n]=t._setFieldName(n);const e=this.encodeComparisonCommand(r[n]);this.mergeConditionAfterEncode(r,e,n)}else a.isConversionRequired(t)&&(r[n]=a.encodeInternalDataType(t))}return r}mergeConditionAfterEncode(e,o,n){o[n]||delete e[n];for(const t in o)e[t]?r.isArray(e[t])?e[t]=e[t].concat(o[t]):r.isObject(e[t])?r.isObject(o[t])?Object.assign(e,o):(console.warn(`unmergable condition, query is object but condition is ${r.getType(o)}, can only overwrite`,o,n),e[t]=o[t]):(console.warn(`to-merge query is of type ${r.getType(e)}, can only overwrite`,e,o,n),e[t]=o[t]):e[t]=o[t]}}