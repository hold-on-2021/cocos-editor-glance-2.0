"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=require("../helper/symbol"),r=require("../utils/type"),t=require("../geo/index"),n=require("../serverDate/index");exports.serialize=function(t){return function t(n,i){if(!r.isInternalObject(n)){if(r.isDate(n))return{$date:+n};if(r.isRegExp(n))return{$regex:n.source,$options:n.flags};if(r.isArray(n))return n.map(e=>{if(i.indexOf(e)>-1)throw new Error("Cannot convert circular structure to JSON");return t(e,[...i,e])});if(r.isObject(n)){const e=Object.assign({},n);for(const r in e){if(i.indexOf(e[r])>-1)throw new Error("Cannot convert circular structure to JSON");e[r]=t(e[r],[...i,e[r]])}return e}return n}switch(n._internalType){case e.SYMBOL_GEO_POINT:return n.toJSON();case e.SYMBOL_SERVER_DATE:case e.SYMBOL_REGEXP:return n.parse();default:return n.toJSON?n.toJSON():n}}(t,[t])},exports.deserialize=function(e){const i=Object.assign({},e);for(const e in i)switch(e){case"$date":switch(r.getType(i[e])){case"number":return new Date(i[e]);case"object":return new n.ServerDate(i[e])}break;case"type":switch(i.type){case"Point":if(r.isArray(i.coordinates)&&r.isNumber(i.coordinates[0])&&r.isNumber(i.coordinates[1]))return new t.Point(i.coordinates[0],i.coordinates[1])}}return e};