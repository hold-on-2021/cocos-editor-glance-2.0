"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=require("../utils/type"),t=require("./datatype");function n(t,r,o,i){const s=Object.assign({},t);for(const c in t){if(/^\$/.test(c))continue;const u=t[c];if(u&&(e.isObject(u)&&!r(u))){if(i.indexOf(u)>-1)throw new Error("Cannot convert circular structure to JSON");const e=n(u,r,[...o,c],[...i,u]);s[c]=e;let t=!1;for(const n in e)/^\$/.test(n)?t=!0:(s[`${c}.${n}`]=e[n],delete s[c][n]);t||delete s[c]}}return s}function r(t){return e.isInternalObject(t)||e.isDate(t)||e.isRegExp(t)}exports.flattenQueryObject=function(e){return n(e,r,[],[e])},exports.flattenObject=function(e){return n(e,e=>!1,[],[e])},exports.mergeConditionAfterEncode=function(t,n,r){n[r]||delete t[r];for(const o in n)t[o]?e.isArray(t[o])?t[o].push(n[o]):e.isObject(t[o])?e.isObject(n[o])?Object.assign(t[o],n[o]):(console.warn(`unmergable condition, query is object but condition is ${e.getType(n)}, can only overwrite`,n,r),t[o]=n[o]):(console.warn(`to-merge query is of type ${e.getType(t)}, can only overwrite`,t,n,r),t[o]=n[o]):t[o]=n[o]},exports.isConversionRequired=r,exports.encodeInternalDataType=function(e){return t.serialize(e)},exports.decodeInternalDataType=function(e){return t.deserialize(e)};