"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=require("lodash/set"),t=require("lodash/unset"),s=require("lodash/cloneDeep"),i=require("./message"),r=require("../utils/error"),n=require("../config/error.config"),o=require("../utils/utils"),a=require("./listener"),c=require("./snapshot"),h=require("./error");var l;(function(e){e.LOGGINGIN="LOGGINGIN",e.INITING="INITING",e.REBUILDING="REBUILDING",e.ACTIVE="ACTIVE",e.ERRORED="ERRORED",e.CLOSING="CLOSING",e.CLOSED="CLOSED",e.PAUSED="PAUSED",e.RESUMING="RESUMING"})(l||(l={}));const d=100,u=2,E=2,I=1e4,_=1e4,m=1e4;function v(e){const t={id:e.ID,dataType:e.DataType,queueType:e.QueueType,docId:e.DocID,doc:e.Doc&&"{}"!==e.Doc?JSON.parse(e.Doc):void 0};return"update"===e.DataType&&(e.UpdatedFields&&(t.updatedFields=JSON.parse(e.UpdatedFields)),(e.removedFields||e.RemovedFields)&&(t.removedFields=JSON.parse(e.removedFields))),t}exports.VirtualWebSocketClient=class{constructor(e){this.watchStatus=l.INITING,this._login=(async(e,t)=>{this.watchStatus=l.LOGGINGIN;const s=await this.login(e,t);return this.envId||(this.envId=s.envId),s}),this.initWatch=(async e=>{if(this._initWatchPromise)return this._initWatchPromise;this._initWatchPromise=new Promise(async(t,s)=>{try{if(this.watchStatus===l.PAUSED)return console.log("[realtime] initWatch cancelled on pause"),t();const{envId:r}=await this._login(this.envId,e);if(this.watchStatus===l.PAUSED)return console.log("[realtime] initWatch cancelled on pause"),t();this.watchStatus=l.INITING;const n={watchId:this.watchId,requestId:i.genRequestId(),msgType:"INIT_WATCH",msgData:{envId:r,collName:this.collectionName,query:this.query}},o=await this.send({msg:n,waitResponse:!0,skipOnMessage:!0,timeout:_}),{events:a,currEvent:h}=o.msgData;if(this.sessionInfo={queryID:o.msgData.queryID,currentEventId:h-1,currentDocs:[]},a.length>0){for(const e of a)e.ID=h;this.handleServerEvents(o)}else{this.sessionInfo.currentEventId=h;const e=new c.Snapshot({id:h,docChanges:[],docs:[],type:"init"});this.listener.onChange(e),this.scheduleSendACK()}this.onWatchStart(this,this.sessionInfo.queryID),this.watchStatus=l.ACTIVE,this._availableRetries.INIT_WATCH=u,t()}catch(e){this.handleWatchEstablishmentError(e,{operationName:"INIT_WATCH",resolve:t,reject:s})}});let t=!1;try{await this._initWatchPromise,t=!0}finally{this._initWatchPromise=void 0}console.log(`[realtime] initWatch ${t?"success":"fail"}`)}),this.rebuildWatch=(async e=>{if(this._rebuildWatchPromise)return this._rebuildWatchPromise;this._rebuildWatchPromise=new Promise(async(t,s)=>{try{if(this.watchStatus===l.PAUSED)return console.log("[realtime] rebuildWatch cancelled on pause"),t();const{envId:r}=await this._login(this.envId,e);if(!this.sessionInfo)throw new Error("can not rebuildWatch without a successful initWatch (lack of sessionInfo)");if(this.watchStatus===l.PAUSED)return console.log("[realtime] rebuildWatch cancelled on pause"),t();this.watchStatus=l.REBUILDING;const n={watchId:this.watchId,requestId:i.genRequestId(),msgType:"REBUILD_WATCH",msgData:{envId:r,collName:this.collectionName,queryID:this.sessionInfo.queryID,eventID:this.sessionInfo.currentEventId}},o=await this.send({msg:n,waitResponse:!0,skipOnMessage:!1,timeout:m});this.handleServerEvents(o),this.watchStatus=l.ACTIVE,this._availableRetries.REBUILD_WATCH=u,t()}catch(e){this.handleWatchEstablishmentError(e,{operationName:"REBUILD_WATCH",resolve:t,reject:s})}});let t=!1;try{await this._rebuildWatchPromise,t=!0}finally{this._rebuildWatchPromise=void 0}console.log(`[realtime] rebuildWatch ${t?"success":"fail"}`)}),this.handleWatchEstablishmentError=(async(e,t)=>{const s="INIT_WATCH"===t.operationName,i=()=>{this.closeWithError(new r.CloudSDKError({errCode:s?n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL,errMsg:e})),t.reject(e)},a=e=>{this.useRetryTicket(t.operationName)?s?(this._initWatchPromise=void 0,t.resolve(this.initWatch(e))):(this._rebuildWatchPromise=void 0,t.resolve(this.rebuildWatch(e))):i()};this.handleCommonError(e,{onSignError:()=>a(!0),onTimeoutError:()=>a(!1),onNotRetryableError:i,onCancelledError:t.reject,onUnknownError:async()=>{try{const e=async()=>{this.pause(),await this.onceWSConnected(),a(!0)};this.isWSConnected()?(await o.sleep(d),this.watchStatus===l.PAUSED?t.reject(new r.CancelledError(`${t.operationName} cancelled due to pause after unknownError`)):this.isWSConnected()?a(!1):await e()):await e()}catch(e){a(!0)}}})}),this.closeWatch=(async()=>{const e=this.sessionInfo?this.sessionInfo.queryID:"";if(this.watchStatus!==l.ACTIVE)return this.watchStatus=l.CLOSED,this.onWatchClose(this,e),void 0;try{this.watchStatus=l.CLOSING;const t={watchId:this.watchId,requestId:i.genRequestId(),msgType:"CLOSE_WATCH",msgData:null};await this.send({msg:t}),this.sessionInfo=void 0,this.watchStatus=l.CLOSED}catch(e){this.closeWithError(new r.CloudSDKError({errCode:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL,errMsg:e}))}finally{this.onWatchClose(this,e)}}),this.scheduleSendACK=(()=>{this.clearACKSchedule(),this._ackTimeoutId=setTimeout(()=>{this._waitExpectedTimeoutId?this.scheduleSendACK():this.sendACK()},I)}),this.clearACKSchedule=(()=>{this._ackTimeoutId&&clearTimeout(this._ackTimeoutId)}),this.sendACK=(async()=>{try{if(this.watchStatus!==l.ACTIVE)return this.scheduleSendACK(),void 0;if(!this.sessionInfo)return console.warn("[realtime listener] can not send ack without a successful initWatch (lack of sessionInfo)"),void 0;const e={watchId:this.watchId,requestId:i.genRequestId(),msgType:"CHECK_LAST",msgData:{queryID:this.sessionInfo.queryID,eventID:this.sessionInfo.currentEventId}};await this.send({msg:e}),this.scheduleSendACK()}catch(e){if(h.isRealtimeErrorMessageError(e)){const t=e.payload;switch(t.msgData.code){case"CHECK_LOGIN_FAILED":case"SIGN_EXPIRED_ERROR":case"SIGN_INVALID_ERROR":case"SIGN_PARAM_INVALID":return this.rebuildWatch(),void 0;case"QUERYID_INVALID_ERROR":case"SYS_ERR":case"INVALIID_ENV":case"COLLECTION_PERMISSION_DENIED":return this.closeWithError(new r.CloudSDKError({errCode:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,errMsg:t.msgData.code})),void 0}}this._availableRetries.CHECK_LAST&&this._availableRetries.CHECK_LAST>0?(this._availableRetries.CHECK_LAST--,this.scheduleSendACK()):this.closeWithError(new r.CloudSDKError({errCode:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,errMsg:e}))}}),this.handleCommonError=((e,t)=>{if(h.isRealtimeErrorMessageError(e))switch(e.payload.msgData.code){case"CHECK_LOGIN_FAILED":case"SIGN_EXPIRED_ERROR":case"SIGN_INVALID_ERROR":case"SIGN_PARAM_INVALID":return t.onSignError(e),void 0;case"QUERYID_INVALID_ERROR":case"SYS_ERR":case"INVALIID_ENV":case"COLLECTION_PERMISSION_DENIED":default:return t.onNotRetryableError(e),void 0}else{if(r.isTimeoutError(e))return t.onTimeoutError(e),void 0;if(r.isCancelledError(e))return t.onCancelledError(e),void 0}t.onUnknownError(e)}),this.watchId=`watchid_${+new Date}_${Math.random()}`,this.envId=e.envId,this.collectionName=e.collectionName,this.query=e.query,this.send=e.send,this.login=e.login,this.isWSConnected=e.isWSConnected,this.onceWSConnected=e.onceWSConnected,this.getWaitExpectedTimeoutLength=e.getWaitExpectedTimeoutLength,this.onWatchStart=e.onWatchStart,this.onWatchClose=e.onWatchClose,this.debug=e.debug,this._availableRetries={INIT_WATCH:u,REBUILD_WATCH:u,CHECK_LAST:E},this.listener=new a.RealtimeListener({close:this.closeWatch,onChange:e.onChange,onError:e.onError,debug:this.debug,virtualClient:this}),this.initWatch()}useRetryTicket(e){return!!(this._availableRetries[e]&&this._availableRetries[e]>0)&&(this._availableRetries[e]--,console.log(`[realtime] ${e} use a retry ticket, now only ${this._availableRetries[e]} retry left`),!0)}async handleServerEvents(e){try{this.scheduleSendACK(),await this._handleServerEvents(e),this._postHandleServerEventsValidityCheck(e)}catch(e){throw console.error("[realtime listener] internal non-fatal error: handle server events failed with error: ",e),e}}async _handleServerEvents(i){const{requestId:o}=i,{events:a}=i.msgData,{msgType:h}=i;if(!a.length||!this.sessionInfo)return;const l=this.sessionInfo;let d;try{d=a.map(v)}catch(e){return this.closeWithError(new r.CloudSDKError({errCode:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA,errMsg:e})),void 0}let u=[...l.currentDocs],E=!1;for(let a=0,I=d.length;a<I;a++){const _=d[a];if(l.currentEventId>=_.id)!d[a-1]||_.id>d[a-1].id?console.warn(`[realtime] duplicate event received, cur ${l.currentEventId} but got ${_.id}`):console.error(`[realtime listener] server non-fatal error: events out of order (the latter event's id is smaller than that of the former) (requestId ${o})`);else{if(l.currentEventId!==_.id-1)return console.warn(`[realtime listener] event received is out of order, cur ${this.sessionInfo.currentEventId} but got ${_.id}`),await this.rebuildWatch(),void 0;switch(_.dataType){case"update":if(!_.doc)switch(_.queueType){case"update":case"dequeue":{const i=u.find(e=>e._id===_.docId);if(i){const r=s.default(i);if(_.updatedFields)for(const t in _.updatedFields)e.default(r,t,_.updatedFields[t]);if(_.removedFields)for(const e of _.removedFields)t.default(r,e);_.doc=r}else console.error("[realtime listener] internal non-fatal server error: unexpected update dataType event where no doc is associated.");break}case"enqueue":{const e=new r.CloudSDKError({errCode:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,errMsg:`HandleServerEvents: full doc is not provided with dataType="update" and queueType="enqueue" (requestId ${i.requestId})`});throw this.closeWithError(e),e}}break;case"replace":if(!_.doc){const e=new r.CloudSDKError({errCode:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,errMsg:`HandleServerEvents: full doc is not provided with dataType="replace" (requestId ${i.requestId})`});throw this.closeWithError(e),e}break;case"remove":{const e=u.find(e=>e._id===_.docId);e?_.doc=e:console.error("[realtime listener] internal non-fatal server error: unexpected remove event where no doc is associated.");break}}switch(_.queueType){case"init":E?u.push(_.doc):(E=!0,u=[_.doc]);break;case"enqueue":u.push(_.doc);break;case"dequeue":{const e=u.findIndex(e=>e._id===_.docId);e>-1?u.splice(e,1):console.error("[realtime listener] internal non-fatal server error: unexpected dequeue event where no doc is associated.");break}case"update":{const e=u.findIndex(e=>e._id===_.docId);e>-1?u[e]=_.doc:console.error("[realtime listener] internal non-fatal server error: unexpected queueType update event where no doc is associated.");break}}if(a===I-1||d[a+1]&&d[a+1].id!==_.id){const e=[...u],t=d.slice(0,a+1).filter(e=>e.id===_.id);this.sessionInfo.currentEventId=_.id,this.sessionInfo.currentDocs=u;const s=new c.Snapshot({id:_.id,docChanges:t,docs:e,msgType:h});this.listener.onChange(s)}}}}_postHandleServerEventsValidityCheck(e){return this.sessionInfo?(this.sessionInfo.expectEventId&&this.sessionInfo.currentEventId>=this.sessionInfo.expectEventId&&this.clearWaitExpectedEvent(),this.sessionInfo.currentEventId<e.msgData.currEvent?(console.warn("[realtime listener] internal non-fatal error: client eventId does not match with server event id after server event handling"),void 0):void 0):(console.error("[realtime listener] internal non-fatal error: sessionInfo lost after server event handling, this should never occur"),void 0)}clearWaitExpectedEvent(){this._waitExpectedTimeoutId&&(clearTimeout(this._waitExpectedTimeoutId),this._waitExpectedTimeoutId=void 0)}onMessage(e){switch(this.watchStatus){case l.PAUSED:if("ERROR"!==e.msgType)return;break;case l.LOGGINGIN:case l.INITING:case l.REBUILDING:return console.warn(`[realtime listener] internal non-fatal error: unexpected message received while ${this.watchStatus}`),void 0;case l.CLOSED:return console.warn("[realtime listener] internal non-fatal error: unexpected message received when the watch has closed"),void 0;case l.ERRORED:return console.warn("[realtime listener] internal non-fatal error: unexpected message received when the watch has ended with error"),void 0}if(!this.sessionInfo)return console.warn("[realtime listener] internal non-fatal error: sessionInfo not found while message is received."),void 0;switch(this.scheduleSendACK(),e.msgType){case"NEXT_EVENT":console.warn(`nextevent ${e.msgData.currEvent} ignored`,e),this.handleServerEvents(e);break;case"CHECK_EVENT":this.sessionInfo.currentEventId<e.msgData.currEvent&&(this.sessionInfo.expectEventId=e.msgData.currEvent,this.clearWaitExpectedEvent(),this._waitExpectedTimeoutId=setTimeout(()=>{this.rebuildWatch()},this.getWaitExpectedTimeoutLength()),console.log(`[realtime] waitExpectedTimeoutLength ${this.getWaitExpectedTimeoutLength()}`));break;case"ERROR":this.closeWithError(new r.CloudSDKError({errCode:n.ERR_CODE.SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG,errMsg:`${e.msgData.code} - ${e.msgData.message}`}));break;default:console.warn(`[realtime listener] virtual client receive unexpected msg ${e.msgType}: `,e)}}closeWithError(e){this.watchStatus=l.ERRORED,this.clearACKSchedule(),this.listener.onError(e),this.onWatchClose(this,this.sessionInfo&&this.sessionInfo.queryID||""),console.log(`[realtime] client closed (${this.collectionName} ${this.query}) (watchId ${this.watchId})`)}pause(){this.watchStatus=l.PAUSED,console.log(`[realtime] client paused (${this.collectionName} ${this.query}) (watchId ${this.watchId})`)}async resume(){this.watchStatus=l.RESUMING,console.log(`[realtime] client resuming with ${this.sessionInfo?"REBUILD_WATCH":"INIT_WATCH"} (${this.collectionName} ${this.query}) (${this.watchId})`);try{await(this.sessionInfo?this.rebuildWatch():this.initWatch()),console.log(`[realtime] client successfully resumed (${this.collectionName} ${this.query}) (${this.watchId})`)}catch(e){console.error(`[realtime] client resume failed (${this.collectionName} ${this.query}) (${this.watchId})`,e)}}};