"use strict";const{randomFillSync:e}=require("crypto"),t=require("./permessage-deflate"),{EMPTY_BUFFER:s}=require("./constants"),{isValidStatusCode:n}=require("./validation"),{mask:i,toBuffer:r}=require("./buffer-util"),o=Buffer.alloc(4);class a{constructor(e,t){this._extensions=t||{},this._socket=e,this._firstFragment=!0,this._compress=!1,this._bufferedBytes=0,this._deflating=!1,this._queue=[]}static frame(t,s){const n=s.mask&&s.readOnly;let r=s.mask?6:2,a=t.length;t.length>=65536?(r+=8,a=127):t.length>125&&(r+=2,a=126);const h=Buffer.allocUnsafe(n?t.length+r:r);return h[0]=s.fin?128|s.opcode:s.opcode,s.rsv1&&(h[0]|=64),h[1]=a,126===a?h.writeUInt16BE(t.length,2):127===a&&(h.writeUInt32BE(0,2),h.writeUInt32BE(t.length,6)),s.mask?(e(o,0,4),h[1]|=128,h[r-4]=o[0],h[r-3]=o[1],h[r-2]=o[2],h[r-1]=o[3],n?(i(t,o,h,r,t.length),[h]):(i(t,o,t,0,t.length),[h,t])):[h,t]}close(e,t,i,r){let o;if(void 0===e)o=s;else{if("number"!=typeof e||!n(e))throw new TypeError("First argument must be a valid error code number");if(void 0===t||""===t)(o=Buffer.allocUnsafe(2)).writeUInt16BE(e,0);else{const s=Buffer.byteLength(t);if(s>123)throw new RangeError("The message must not be greater than 123 bytes");(o=Buffer.allocUnsafe(2+s)).writeUInt16BE(e,0),o.write(t,2)}}this._deflating?this.enqueue([this.doClose,o,i,r]):this.doClose(o,i,r)}doClose(e,t,s){this.sendFrame(a.frame(e,{fin:!0,rsv1:!1,opcode:8,mask:t,readOnly:!1}),s)}ping(e,t,s){const n=r(e);if(n.length>125)throw new RangeError("The data size must not be greater than 125 bytes");this._deflating?this.enqueue([this.doPing,n,t,r.readOnly,s]):this.doPing(n,t,r.readOnly,s)}doPing(e,t,s,n){this.sendFrame(a.frame(e,{fin:!0,rsv1:!1,opcode:9,mask:t,readOnly:s}),n)}pong(e,t,s){const n=r(e);if(n.length>125)throw new RangeError("The data size must not be greater than 125 bytes");this._deflating?this.enqueue([this.doPong,n,t,r.readOnly,s]):this.doPong(n,t,r.readOnly,s)}doPong(e,t,s,n){this.sendFrame(a.frame(e,{fin:!0,rsv1:!1,opcode:10,mask:t,readOnly:s}),n)}send(e,s,n){const i=r(e),o=this._extensions[t.extensionName];let h=s.binary?2:1,d=s.compress;if(this._firstFragment?(this._firstFragment=!1,d&&o&&(d=i.length>=o._threshold),this._compress=d):(d=!1,h=0),s.fin&&(this._firstFragment=!0),o){const e={fin:s.fin,rsv1:d,opcode:h,mask:s.mask,readOnly:r.readOnly};this._deflating?this.enqueue([this.dispatch,i,this._compress,e,n]):this.dispatch(i,this._compress,e,n)}else this.sendFrame(a.frame(i,{fin:s.fin,rsv1:!1,opcode:h,mask:s.mask,readOnly:r.readOnly}),n)}dispatch(e,s,n,i){if(!s)return this.sendFrame(a.frame(e,n),i),void 0;const r=this._extensions[t.extensionName];this._deflating=!0,r.compress(e,n.fin,(e,t)=>{if(this._socket.destroyed){const e=new Error("The socket was closed while data was being compressed");"function"==typeof i&&i(e);for(let t=0;t<this._queue.length;t++){const s=this._queue[t][4];"function"==typeof s&&s(e)}}else this._deflating=!1,n.readOnly=!1,this.sendFrame(a.frame(t,n),i),this.dequeue()})}dequeue(){for(;!this._deflating&&this._queue.length;){const e=this._queue.shift();this._bufferedBytes-=e[1].length,Reflect.apply(e[0],this,e.slice(1))}}enqueue(e){this._bufferedBytes+=e[1].length,this._queue.push(e)}sendFrame(e,t){2===e.length?(this._socket.cork(),this._socket.write(e[0]),this._socket.write(e[1],t),this._socket.uncork()):this._socket.write(e[0],t)}}module.exports=a;