"use strict";const e=require("events"),t=require("https"),s=require("http"),r=require("net"),o=require("tls"),{randomBytes:i,createHash:n}=require("crypto"),{URL:a}=require("url"),c=require("./permessage-deflate"),d=require("./receiver"),h=require("./sender"),{BINARY_TYPES:u,EMPTY_BUFFER:l,GUID:p,kStatusCode:f,kWebSocket:_,NOOP:S}=require("./constants"),{addEventListener:m,removeEventListener:v}=require("./event-target"),{format:y,parse:N}=require("./extension"),{toBuffer:C}=require("./buffer-util"),b=["CONNECTING","OPEN","CLOSING","CLOSED"],g=[8,13],k=3e4;class E extends e{constructor(e,r,o){super(),this.readyState=E.CONNECTING,this.protocol="",this._binaryType=u[0],this._closeFrameReceived=!1,this._closeFrameSent=!1,this._closeMessage="",this._closeTimer=null,this._closeCode=1006,this._extensions={},this._receiver=null,this._sender=null,this._socket=null,null!==e?(this._bufferedAmount=0,this._isServer=!1,this._redirects=0,Array.isArray(r)?r=r.join(", "):"object"==typeof r&&null!==r&&(o=r,r=void 0),function e(r,o,d,h){const u={protocolVersion:g[1],maxPayload:104857600,perMessageDeflate:!0,followRedirects:!1,maxRedirects:10,...h,createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:void 0,auth:void 0,host:void 0,path:void 0,port:void 0};if(!g.includes(u.protocolVersion))throw new RangeError(`Unsupported protocol version: ${u.protocolVersion} `+`(supported versions: ${g.join(", ")})`);let l;o instanceof a?(l=o,r.url=o.href):(l=new a(o),r.url=o);const f="ws+unix:"===l.protocol;if(!(l.host||f&&l.pathname))throw new Error(`Invalid URL: ${r.url}`);const _="wss:"===l.protocol||"https:"===l.protocol;const S=_?443:80;const m=i(16).toString("base64");const v=_?t.get:s.get;let C;u.createConnection=_?w:O;u.defaultPort=u.defaultPort||S;u.port=l.port||S;u.host=l.hostname.startsWith("[")?l.hostname.slice(1,-1):l.hostname;u.headers={"Sec-WebSocket-Version":u.protocolVersion,"Sec-WebSocket-Key":m,Connection:"Upgrade",Upgrade:"websocket",...u.headers};u.path=l.pathname+l.search;u.timeout=u.handshakeTimeout;u.perMessageDeflate&&(C=new c(!0!==u.perMessageDeflate?u.perMessageDeflate:{},!1,u.maxPayload),u.headers["Sec-WebSocket-Extensions"]=y({[c.extensionName]:C.offer()}));d&&(u.headers["Sec-WebSocket-Protocol"]=d);u.origin&&(u.protocolVersion<13?u.headers["Sec-WebSocket-Origin"]=u.origin:u.headers.Origin=u.origin);(l.username||l.password)&&(u.auth=`${l.username}:${l.password}`);if(f){const e=u.path.split(":");u.socketPath=e[0],u.path=e[1]}let b=r._req=v(u);u.timeout&&b.on("timeout",()=>{L(r,b,"Opening handshake has timed out")});b.on("error",e=>{r._req.aborted||(b=r._req=null,r.readyState=E.CLOSING,r.emit("error",e),r.emitClose())});b.on("response",t=>{const s=t.headers.location,i=t.statusCode;if(s&&u.followRedirects&&i>=300&&i<400){if(++r._redirects>u.maxRedirects)return L(r,b,"Maximum redirects exceeded"),void 0;b.abort();const t=new a(s,o);e(r,t,d,h)}else r.emit("unexpected-response",b,t)||L(r,b,`Unexpected server response: ${t.statusCode}`)});b.on("upgrade",(e,t,s)=>{if(r.emit("upgrade",e),r.readyState!==E.CONNECTING)return;b=r._req=null;const o=n("sha1").update(m+p).digest("base64");if(e.headers["sec-websocket-accept"]!==o)return L(r,t,"Invalid Sec-WebSocket-Accept header"),void 0;const i=e.headers["sec-websocket-protocol"],a=(d||"").split(/, */);let h;if(!d&&i?h="Server sent a subprotocol but none was requested":d&&!i?h="Server sent no subprotocol":i&&!a.includes(i)&&(h="Server sent an invalid subprotocol"),h)return L(r,t,h),void 0;if(i&&(r.protocol=i),C)try{const s=N(e.headers["sec-websocket-extensions"]);s[c.extensionName]&&(C.accept(s[c.extensionName]),r._extensions[c.extensionName]=C)}catch(e){return L(r,t,"Invalid Sec-WebSocket-Extensions header"),void 0}r.setSocket(t,s,u.maxPayload)})}(this,e,r,o)):this._isServer=!0}get CONNECTING(){return E.CONNECTING}get CLOSING(){return E.CLOSING}get CLOSED(){return E.CLOSED}get OPEN(){return E.OPEN}get binaryType(){return this._binaryType}set binaryType(e){u.includes(e)&&(this._binaryType=e,this._receiver&&(this._receiver._binaryType=e))}get bufferedAmount(){return this._socket?(this._socket.bufferSize||0)+this._sender._bufferedBytes:this._bufferedAmount}get extensions(){return Object.keys(this._extensions).join()}setSocket(e,t,s){const r=new d(this._binaryType,this._extensions,this._isServer,s);this._sender=new h(e,this._extensions),this._receiver=r,this._socket=e,r[_]=this,e[_]=this,r.on("conclude",I),r.on("drain",T),r.on("error",G),r.on("message",P),r.on("ping",W),r.on("pong",D),e.setTimeout(0),e.setNoDelay(),t.length>0&&e.unshift(t),e.on("close",R),e.on("data",M),e.on("end",A),e.on("error",F),this.readyState=E.OPEN,this.emit("open")}emitClose(){if(!this._socket)return this.readyState=E.CLOSED,this.emit("close",this._closeCode,this._closeMessage),void 0;this._extensions[c.extensionName]&&this._extensions[c.extensionName].cleanup(),this._receiver.removeAllListeners(),this.readyState=E.CLOSED,this.emit("close",this._closeCode,this._closeMessage)}close(e,t){if(this.readyState!==E.CLOSED){if(this.readyState===E.CONNECTING){const e="WebSocket was closed before the connection was established";return L(this,this._req,e)}if(this.readyState===E.CLOSING)return this._closeFrameSent&&this._closeFrameReceived&&this._socket.end(),void 0;this.readyState=E.CLOSING,this._sender.close(e,t,!this._isServer,e=>{e||(this._closeFrameSent=!0,this._closeFrameReceived&&this._socket.end())}),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),k)}}ping(e,t,s){if(this.readyState===E.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if("function"==typeof e?(s=e,e=t=void 0):"function"==typeof t&&(s=t,t=void 0),"number"==typeof e&&(e=e.toString()),this.readyState!==E.OPEN)return x(this,e,s),void 0;void 0===t&&(t=!this._isServer),this._sender.ping(e||l,t,s)}pong(e,t,s){if(this.readyState===E.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if("function"==typeof e?(s=e,e=t=void 0):"function"==typeof t&&(s=t,t=void 0),"number"==typeof e&&(e=e.toString()),this.readyState!==E.OPEN)return x(this,e,s),void 0;void 0===t&&(t=!this._isServer),this._sender.pong(e||l,t,s)}send(e,t,s){if(this.readyState===E.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if("function"==typeof t&&(s=t,t={}),"number"==typeof e&&(e=e.toString()),this.readyState!==E.OPEN)return x(this,e,s),void 0;const r={binary:"string"!=typeof e,mask:!this._isServer,compress:!0,fin:!0,...t};this._extensions[c.extensionName]||(r.compress=!1),this._sender.send(e||l,r,s)}terminate(){if(this.readyState!==E.CLOSED){if(this.readyState===E.CONNECTING){const e="WebSocket was closed before the connection was established";return L(this,this._req,e)}this._socket&&(this.readyState=E.CLOSING,this._socket.destroy())}}}function O(e){return e.path=e.socketPath,r.connect(e)}function w(e){return e.path=void 0,e.servername||""===e.servername||(e.servername=e.host),o.connect(e)}function L(e,t,s){e.readyState=E.CLOSING;const r=new Error(s);Error.captureStackTrace(r,L),t.setHeader?(t.abort(),t.once("abort",e.emitClose.bind(e)),e.emit("error",r)):(t.destroy(r),t.once("error",e.emit.bind(e,"error")),t.once("close",e.emitClose.bind(e)))}function x(e,t,s){if(t){const s=C(t).length;e._socket?e._sender._bufferedBytes+=s:e._bufferedAmount+=s}if(s){s(new Error(`WebSocket is not open: readyState ${e.readyState} `+`(${b[e.readyState]})`))}}function I(e,t){const s=this[_];s._socket.removeListener("data",M),s._socket.resume(),s._closeFrameReceived=!0,s._closeMessage=t,s._closeCode=e,1005===e?s.close():s.close(e,t)}function T(){this[_]._socket.resume()}function G(e){const t=this[_];t._socket.removeListener("data",M),t.readyState=E.CLOSING,t._closeCode=e[f],t.emit("error",e),t._socket.destroy()}function q(){this[_].emitClose()}function P(e){this[_].emit("message",e)}function W(e){const t=this[_];t.pong(e,!t._isServer,S),t.emit("ping",e)}function D(e){this[_].emit("pong",e)}function R(){const e=this[_];this.removeListener("close",R),this.removeListener("end",A),e.readyState=E.CLOSING,e._socket.read(),e._receiver.end(),this.removeListener("data",M),this[_]=void 0,clearTimeout(e._closeTimer),e._receiver._writableState.finished||e._receiver._writableState.errorEmitted?e.emitClose():(e._receiver.on("error",q),e._receiver.on("finish",q))}function M(e){this[_]._receiver.write(e)||this.pause()}function A(){const e=this[_];e.readyState=E.CLOSING,e._receiver.end(),this.end()}function F(){const e=this[_];this.removeListener("error",F),this.on("error",S),e&&(e.readyState=E.CLOSING,this.destroy())}b.forEach((e,t)=>{E[e]=t}),["open","error","close","message"].forEach(e=>{Object.defineProperty(E.prototype,`on${e}`,{get(){const t=this.listeners(e);for(let e=0;e<t.length;e++)if(t[e]._listener)return t[e]._listener},set(t){const s=this.listeners(e);for(let t=0;t<s.length;t++)s[t]._listener&&this.removeListener(e,s[t]);this.addEventListener(e,t)}})}),E.prototype.addEventListener=m,E.prototype.removeEventListener=v,module.exports=E;