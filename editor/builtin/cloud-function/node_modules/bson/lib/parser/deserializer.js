"use strict";const Buffer=require("buffer").Buffer,Long=require("../long"),Double=require("../double"),Timestamp=require("../timestamp"),ObjectId=require("../objectid"),Code=require("../code"),MinKey=require("../min_key"),MaxKey=require("../max_key"),Decimal128=require("../decimal128"),Int32=require("../int_32"),DBRef=require("../db_ref"),BSONRegExp=require("../regexp"),Binary=require("../binary"),constants=require("../constants"),validateUtf8=require("../validate_utf8").validateUtf8,JS_INT_MAX_LONG=Long.fromNumber(constants.JS_INT_MAX),JS_INT_MIN_LONG=Long.fromNumber(constants.JS_INT_MIN),functionCache={};function deserialize(e,t,n){const r=(t=null==t?{}:t)&&t.index?t.index:0,o=e[r]|e[r+1]<<8|e[r+2]<<16|e[r+3]<<24;if(o<5)throw new Error(`bson size must be >= 5, is ${o}`);if(t.allowObjectSmallerThanBufferSize&&e.length<o)throw new Error(`buffer length ${e.length} must be >= bson size ${o}`);if(!t.allowObjectSmallerThanBufferSize&&e.length!==o)throw new Error(`buffer length ${e.length} must === bson size ${o}`);if(o+r>e.length)throw new Error(`(bson size ${o} + options.index ${r} must be <= buffer length ${Buffer.byteLength(e)})`);if(0!==e[r+o-1])throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");return deserializeObject(e,r,t,n)}function deserializeObject(e,t,n,r){const o=null!=n.evalFunctions&&n.evalFunctions,i=null!=n.cacheFunctions&&n.cacheFunctions,s=null!=n.cacheFunctionsCrc32&&n.cacheFunctionsCrc32;if(!s)var l=null;const a=null==n.fieldsAsRaw?null:n.fieldsAsRaw,c=null!=n.raw&&n.raw,f="boolean"==typeof n.bsonRegExp&&n.bsonRegExp,u=null!=n.promoteBuffers&&n.promoteBuffers,h=null==n.promoteLongs||n.promoteLongs,w=null==n.promoteValues||n.promoteValues;let g=t;if(e.length<5)throw new Error("corrupt bson message < 5 bytes long");const b=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(b<5||b>e.length)throw new Error("corrupt bson message");const _=r?[]:{};let d=0;for(;;){const g=e[t++];if(0===g)break;let b=t;for(;0!==e[b]&&b<e.length;)b++;if(b>=Buffer.byteLength(e))throw new Error("Bad BSON Document: illegal CString");const E=r?d++:e.toString("utf8",t,b);if(t=b+1,g===constants.BSON_DATA_STRING){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new Error("bad string length in bson");if(!validateUtf8(e,t,t+n-1))throw new Error("Invalid UTF-8 string in BSON document");const r=e.toString("utf8",t,t+n-1);_[E]=r,t+=n}else if(g===constants.BSON_DATA_OID){const n=Buffer.alloc(12);e.copy(n,0,t,t+12),_[E]=new ObjectId(n),t+=12}else if(g===constants.BSON_DATA_INT&&!1===w)_[E]=new Int32(e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24);else if(g===constants.BSON_DATA_INT)_[E]=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;else if(g===constants.BSON_DATA_NUMBER&&!1===w)_[E]=new Double(e.readDoubleLE(t)),t+=8;else if(g===constants.BSON_DATA_NUMBER)_[E]=e.readDoubleLE(t),t+=8;else if(g===constants.BSON_DATA_DATE){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,r=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;_[E]=new Date(new Long(n,r).toNumber())}else if(g===constants.BSON_DATA_BOOLEAN){if(0!==e[t]&&1!==e[t])throw new Error("illegal boolean type value");_[E]=1===e[t++]}else if(g===constants.BSON_DATA_OBJECT){const r=t,o=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24;if(o<=0||o>e.length-t)throw new Error("bad embedded document length in bson");_[E]=c?e.slice(t,t+o):deserializeObject(e,r,n,!1),t+=o}else if(g===constants.BSON_DATA_ARRAY){const r=t,o=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24;let i=n;const s=t+o;if(a&&a[E]){i={};for(let e in n)i[e]=n[e];i.raw=!0}if(_[E]=deserializeObject(e,r,i,!0),0!==e[(t+=o)-1])throw new Error("invalid array terminator byte");if(t!==s)throw new Error("corrupted array bson")}else if(g===constants.BSON_DATA_UNDEFINED)_[E]=void 0;else if(g===constants.BSON_DATA_NULL)_[E]=null;else if(g===constants.BSON_DATA_LONG){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,r=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,o=new Long(n,r);_[E]=h&&!0===w&&o.lessThanOrEqual(JS_INT_MAX_LONG)&&o.greaterThanOrEqual(JS_INT_MIN_LONG)?o.toNumber():o}else if(g===constants.BSON_DATA_DECIMAL128){const n=Buffer.alloc(16);e.copy(n,0,t,t+16),t+=16;const r=new Decimal128(n);_[E]=r.toObject?r.toObject():r}else if(g===constants.BSON_DATA_BINARY){let n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;const r=n,o=e[t++];if(n<0)throw new Error("Negative binary type element size found");if(n>Buffer.byteLength(e))throw new Error("Binary type size larger than document size");if(null!=e.slice){if(o===Binary.SUBTYPE_BYTE_ARRAY){if((n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24)<0)throw new Error("Negative binary type element size found for subtype 0x02");if(n>r-4)throw new Error("Binary type with subtype 0x02 contains to long binary size");if(n<r-4)throw new Error("Binary type with subtype 0x02 contains to short binary size")}_[E]=u&&w?e.slice(t,t+n):new Binary(e.slice(t,t+n),o)}else{const i="undefined"!=typeof Uint8Array?new Uint8Array(new ArrayBuffer(n)):new Array(n);if(o===Binary.SUBTYPE_BYTE_ARRAY){if((n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24)<0)throw new Error("Negative binary type element size found for subtype 0x02");if(n>r-4)throw new Error("Binary type with subtype 0x02 contains to long binary size");if(n<r-4)throw new Error("Binary type with subtype 0x02 contains to short binary size")}for(b=0;b<n;b++)i[b]=e[t+b];_[E]=u&&w?i:new Binary(i,o)}t+=n}else if(g===constants.BSON_DATA_REGEXP&&!1===f){for(b=t;0!==e[b]&&b<e.length;)b++;if(b>=e.length)throw new Error("Bad BSON Document: illegal CString");const n=e.toString("utf8",t,b);for(b=t=b+1;0!==e[b]&&b<e.length;)b++;if(b>=e.length)throw new Error("Bad BSON Document: illegal CString");const r=e.toString("utf8",t,b);t=b+1;const o=new Array(r.length);for(b=0;b<r.length;b++)switch(r[b]){case"m":o[b]="m";break;case"s":o[b]="g";break;case"i":o[b]="i"}_[E]=new RegExp(n,o.join(""))}else if(g===constants.BSON_DATA_REGEXP&&!0===f){for(b=t;0!==e[b]&&b<e.length;)b++;if(b>=e.length)throw new Error("Bad BSON Document: illegal CString");const n=e.toString("utf8",t,b);for(b=t=b+1;0!==e[b]&&b<e.length;)b++;if(b>=e.length)throw new Error("Bad BSON Document: illegal CString");const r=e.toString("utf8",t,b);t=b+1,_[E]=new BSONRegExp(n,r)}else if(g===constants.BSON_DATA_SYMBOL){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new Error("bad string length in bson");_[E]=e.toString("utf8",t,t+n-1),t+=n}else if(g===constants.BSON_DATA_TIMESTAMP){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24,r=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;_[E]=new Timestamp(n,r)}else if(g===constants.BSON_DATA_MIN_KEY)_[E]=new MinKey;else if(g===constants.BSON_DATA_MAX_KEY)_[E]=new MaxKey;else if(g===constants.BSON_DATA_CODE){const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new Error("bad string length in bson");const r=e.toString("utf8",t,t+n-1);if(o)if(i){const e=s?l(r):r;_[E]=isolateEvalWithHash(functionCache,e,r,_)}else _[E]=isolateEval(r);else _[E]=new Code(r);t+=n}else if(g===constants.BSON_DATA_CODE_W_SCOPE){const r=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(r<13)throw new Error("code_w_scope total size shorter minimum expected length");const a=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(a<=0||a>e.length-t||0!==e[t+a-1])throw new Error("bad string length in bson");const c=e.toString("utf8",t,t+a-1),f=t+=a,u=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24,h=deserializeObject(e,f,n,!1);if(t+=u,r<8+u+a)throw new Error("code_w_scope total size is to short, truncating scope");if(r>8+u+a)throw new Error("code_w_scope total size is to long, clips outer document");if(o){if(i){const e=s?l(c):c;_[E]=isolateEvalWithHash(functionCache,e,c,_)}else _[E]=isolateEval(c);_[E].scope=h}else _[E]=new Code(c,h)}else{if(g!==constants.BSON_DATA_DBPOINTER)throw new Error("Detected unknown BSON type "+g.toString(16)+' for fieldname "'+E+'", are you using the latest BSON parser?');{const n=e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24;if(n<=0||n>e.length-t||0!==e[t+n-1])throw new Error("bad string length in bson");if(!validateUtf8(e,t,t+n-1))throw new Error("Invalid UTF-8 string in BSON document");const r=e.toString("utf8",t,t+n-1);t+=n;const o=Buffer.alloc(12);e.copy(o,0,t,t+12);const i=new ObjectId(o);t+=12,_[E]=new DBRef(r,i)}}}if(b!==t-g){if(r)throw new Error("corrupt array bson");throw new Error("corrupt object bson")}let E=!0;if(Object.keys(_).filter(e=>e.startsWith("$")).forEach(e=>{-1===["$ref","$id","$db"].indexOf(e)&&(E=!1)}),!E)return _;if(null!=_.$id&&null!=_.$ref){let e=Object.assign({},_);return delete e.$ref,delete e.$id,delete e.$db,new DBRef(_.$ref,_.$id,_.$db||null,e)}return _}function isolateEvalWithHash(functionCache,hash,functionString,object){let value=null;return null==functionCache[hash]&&(eval("value = "+functionString),functionCache[hash]=value),functionCache[hash].bind(object)}function isolateEval(functionString){let value=null;return eval("value = "+functionString),value}module.exports=deserialize;