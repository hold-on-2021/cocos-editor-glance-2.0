"use strict";const t=require("buffer").Buffer;class e{constructor(i,f){if(!(null==i||"string"==typeof i||t.isBuffer(i)||i instanceof Uint8Array||Array.isArray(i)))throw new TypeError("only String, Buffer, Uint8Array or Array accepted");if(this.sub_type=null==f?r:f,this.position=0,null==i||i instanceof Number)void 0!==t?this.buffer=t.alloc(e.BUFFER_SIZE):"undefined"!=typeof Uint8Array?this.buffer=new Uint8Array(new ArrayBuffer(e.BUFFER_SIZE)):this.buffer=new Array(e.BUFFER_SIZE);else{if("string"==typeof i)if(void 0!==t)this.buffer=t.from(i);else{if("undefined"==typeof Uint8Array&&!Array.isArray(i))throw new TypeError("only String, Buffer, Uint8Array or Array accepted");this.buffer=function(t){const e="undefined"!=typeof Uint8Array?new Uint8Array(new ArrayBuffer(t.length)):new Array(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}(i)}else this.buffer=i;this.position=i.length}}put(r){if(null!=r.length&&"number"!=typeof r&&1!==r.length)throw new TypeError("only accepts single character String, Uint8Array or Array");if("number"!=typeof r&&r<0||r>255)throw new TypeError("only accepts number in a valid unsigned byte range 0-255");let f=null;if(f="string"==typeof r?r.charCodeAt(0):null!=r.length?r[0]:r,this.buffer.length>this.position)this.buffer[this.position++]=f;else if(void 0!==t&&t.isBuffer(this.buffer)){let r=t.alloc(e.BUFFER_SIZE+this.buffer.length);this.buffer.copy(r,0,0,this.buffer.length),this.buffer=r,this.buffer[this.position++]=f}else{let t=null;t=i(this.buffer)?new Uint8Array(new ArrayBuffer(e.BUFFER_SIZE+this.buffer.length)):new Array(e.BUFFER_SIZE+this.buffer.length);for(let e=0;e<this.buffer.length;e++)t[e]=this.buffer[e];this.buffer=t,this.buffer[this.position++]=f}}write(e,r){if(r="number"==typeof r?r:this.position,this.buffer.length<r+e.length){let r=null;if(void 0!==t&&t.isBuffer(this.buffer))r=t.alloc(this.buffer.length+e.length),this.buffer.copy(r,0,0,this.buffer.length);else if(i(this.buffer)){r=new Uint8Array(new ArrayBuffer(this.buffer.length+e.length));for(let t=0;t<this.position;t++)r[t]=this.buffer[t]}this.buffer=r}if(void 0!==t&&t.isBuffer(e)&&t.isBuffer(this.buffer))e.copy(this.buffer,r,0,e.length),this.position=r+e.length>this.position?r+e.length:this.position;else if(void 0!==t&&"string"==typeof e&&t.isBuffer(this.buffer))this.buffer.write(e,r,"binary"),this.position=r+e.length>this.position?r+e.length:this.position;else if(i(e)||Array.isArray(e)&&"string"!=typeof e){for(let t=0;t<e.length;t++)this.buffer[r++]=e[t];this.position=r>this.position?r:this.position}else if("string"==typeof e){for(let t=0;t<e.length;t++)this.buffer[r++]=e.charCodeAt(t);this.position=r>this.position?r:this.position}}read(t,e){if(e=e&&e>0?e:this.position,this.buffer.slice)return this.buffer.slice(t,t+e);const r="undefined"!=typeof Uint8Array?new Uint8Array(new ArrayBuffer(e)):new Array(e);for(let i=0;i<e;i++)r[i]=this.buffer[t++];return r}value(e){if((e=null!=e&&e)&&void 0!==t&&t.isBuffer(this.buffer)&&this.buffer.length===this.position)return this.buffer;if(void 0!==t&&t.isBuffer(this.buffer))return e?this.buffer.slice(0,this.position):this.buffer.toString("binary",0,this.position);if(e){if(null!=this.buffer.slice)return this.buffer.slice(0,this.position);{const t=i(this.buffer)?new Uint8Array(new ArrayBuffer(this.position)):new Array(this.position);for(let e=0;e<this.position;e++)t[e]=this.buffer[e];return t}}return function(t,e,r){let i="";for(let f=e;f<r;f++)i+=String.fromCharCode(t[f]);return i}(this.buffer,0,this.position)}length(){return this.position}toJSON(){return null!=this.buffer?this.buffer.toString("base64"):""}toString(t){return null!=this.buffer?this.buffer.slice(0,this.position).toString(t):""}toExtendedJSON(e){e=e||{};const r=t.isBuffer(this.buffer)?this.buffer.toString("base64"):t.from(this.buffer).toString("base64"),i=Number(this.sub_type).toString(16);return e.legacy?{$binary:r,$type:1===i.length?"0"+i:i}:{$binary:{base64:r,subType:1===i.length?"0"+i:i}}}static fromExtendedJSON(r,i){let f,n;return(i=i||{}).legacy?(n=r.$type?parseInt(r.$type,16):0,f=t.from(r.$binary,"base64")):(n=r.$binary.subType?parseInt(r.$binary.subType,16):0,f=t.from(r.$binary.base64,"base64")),new e(f,n)}}const r=0;function i(t){return"[object Uint8Array]"===Object.prototype.toString.call(t)}e.BUFFER_SIZE=256,e.SUBTYPE_DEFAULT=0,e.SUBTYPE_FUNCTION=1,e.SUBTYPE_BYTE_ARRAY=2,e.SUBTYPE_UUID_OLD=3,e.SUBTYPE_UUID=4,e.SUBTYPE_MD5=5,e.SUBTYPE_USER_DEFINED=128,Object.defineProperty(e.prototype,"_bsontype",{value:"Binary"}),module.exports=e;