var e=require("assert-plus"),t=require("crypto"),r=(require("http"),require("util")),i=require("sshpk"),s=require("jsprim"),o=require("./utils"),n=require("util").format,a=o.HASH_ALGOS,h=o.PK_ALGOS,g=o.InvalidAlgorithmError,p=o.HttpSignatureError,u=o.validateAlgorithm,y='Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';function d(e){p.call(this,e,d)}function f(e){p.call(this,e,f)}function l(r){e.object(r,"options");var s=[];if(void 0!==r.algorithm&&(e.string(r.algorithm,"options.algorithm"),s=u(r.algorithm)),this.rs_alg=s,void 0!==r.sign)e.func(r.sign,"options.sign"),this.rs_signFunc=r.sign;else if("hmac"===s[0]&&void 0!==r.key){if(e.string(r.keyId,"options.keyId"),this.rs_keyId=r.keyId,"string"!=typeof r.key&&!Buffer.isBuffer(r.key))throw new TypeError("options.key for HMAC must be a string or Buffer");this.rs_signer=t.createHmac(s[1].toUpperCase(),r.key),this.rs_signer.sign=function(){var e=this.digest("base64");return{hashAlgorithm:s[1],toString:function(){return e}}}}else{if(void 0===r.key)throw new TypeError("options.sign (func) or options.key is required");var o=r.key;if(("string"==typeof o||Buffer.isBuffer(o))&&(o=i.parsePrivateKey(o)),e.ok(i.PrivateKey.isPrivateKey(o,[1,2]),"options.key must be a sshpk.PrivateKey"),this.rs_key=o,e.string(r.keyId,"options.keyId"),this.rs_keyId=r.keyId,!h[o.type])throw new g(o.type.toUpperCase()+" type keys are not supported");if(void 0!==s[0]&&o.type!==s[0])throw new g("options.key must be a "+s[0].toUpperCase()+" key, was given a "+o.type.toUpperCase()+" key instead");this.rs_signer=o.createSign(s[1])}this.rs_headers=[],this.rs_lines=[]}r.inherits(d,p),r.inherits(f,p),l.prototype.writeHeader=function(t,r){if(e.string(t,"header"),t=t.toLowerCase(),e.string(r,"value"),this.rs_headers.push(t),this.rs_signFunc)this.rs_lines.push(t+": "+r);else{var i=t+": "+r;this.rs_headers.length>0&&(i="\n"+i),this.rs_signer.update(i)}return r},l.prototype.writeDateHeader=function(){return this.writeHeader("date",s.rfc1123(new Date))},l.prototype.writeTarget=function(t,r){e.string(t,"method"),e.string(r,"path"),t=t.toLowerCase(),this.writeHeader("(request-target)",t+" "+r)},l.prototype.sign=function(t){if(e.func(t,"callback"),this.rs_headers.length<1)throw new Error("At least one header must be signed");var r,i;if(this.rs_signFunc){var s=this.rs_lines.join("\n"),o=this;this.rs_signFunc(s,function(s,a){if(s)return t(s),void 0;try{e.object(a,"signature"),e.string(a.keyId,"signature.keyId"),e.string(a.algorithm,"signature.algorithm"),e.string(a.signature,"signature.signature"),r=u(a.algorithm),i=n(y,a.keyId,a.algorithm,o.rs_headers.join(" "),a.signature)}catch(e){return t(e),void 0}t(null,i)})}else{try{var a=this.rs_signer.sign()}catch(e){return t(e),void 0}r=(this.rs_alg[0]||this.rs_key.type)+"-"+a.hashAlgorithm;var h=a.toString();i=n(y,this.rs_keyId,r,this.rs_headers.join(" "),h),t(null,i)}},module.exports={isSigner:function(e){return"object"==typeof e&&e instanceof l},createSigner:function(e){return new l(e)},signRequest:function(r,o){e.object(r,"request"),e.object(o,"options"),e.optionalString(o.algorithm,"options.algorithm"),e.string(o.keyId,"options.keyId"),e.optionalArrayOfString(o.headers,"options.headers"),e.optionalString(o.httpVersion,"options.httpVersion"),r.getHeader("Date")||r.setHeader("Date",s.rfc1123(new Date)),o.headers||(o.headers=["date"]),o.httpVersion||(o.httpVersion="1.1");var p,l=[];o.algorithm&&(o.algorithm=o.algorithm.toLowerCase(),l=u(o.algorithm));var c,k="";for(p=0;p<o.headers.length;p++){if("string"!=typeof o.headers[p])throw new TypeError("options.headers must be an array of Strings");var m=o.headers[p].toLowerCase();if("request-line"===m){if(o.strict)throw new f("request-line is not a valid header with strict parsing enabled.");k+=r.method+" "+r.path+" HTTP/"+o.httpVersion}else if("(request-target)"===m)k+="(request-target): "+r.method.toLowerCase()+" "+r.path;else{var v=r.getHeader(m);if(void 0===v||""===v)throw new d(m+" was not in the request");k+=m+": "+v}p+1<o.headers.length&&(k+="\n")}if(r.hasOwnProperty("_stringToSign")&&(r._stringToSign=k),"hmac"===l[0]){if("string"!=typeof o.key&&!Buffer.isBuffer(o.key))throw new TypeError("options.key must be a string or Buffer");var w=t.createHmac(l[1].toUpperCase(),o.key);w.update(k),c=w.digest("base64")}else{var _=o.key;if(("string"==typeof _||Buffer.isBuffer(_))&&(_=i.parsePrivateKey(o.key)),e.ok(i.PrivateKey.isPrivateKey(_,[1,2]),"options.key must be a sshpk.PrivateKey"),!h[_.type])throw new g(_.type.toUpperCase()+" type keys are not supported");if(void 0!==l[0]&&_.type!==l[0])throw new g("options.key must be a "+l[0].toUpperCase()+" key, was given a "+_.type.toUpperCase()+" key instead");var S=_.createSign(l[1]);S.update(k);var q=S.sign();if(!a[q.hashAlgorithm])throw new g(q.hashAlgorithm.toUpperCase()+" is not a supported hash algorithm");o.algorithm=_.type+"-"+q.hashAlgorithm,c=q.toString(),e.notStrictEqual(c,"","empty signature produced")}var b=o.authorizationHeaderName||"Authorization";return r.setHeader(b,n(y,o.keyId,o.algorithm,o.headers.join(" "),c)),!0}};