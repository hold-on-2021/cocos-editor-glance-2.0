import{isArray as t,isMaybeThenable as e}from"./utils";import{noop as i,reject as s,fulfill as r,subscribe as h,FULFILLED as l,REJECTED as n,PENDING as o,handleMaybeThenable as m}from"./-internal";import _ from"./then";import a from"./promise";import p from"./promise/resolve";import u from"./then";import{makePromise as f,PROMISE_ID as g}from"./-internal";export default class Enumerator{constructor(e,h){this._instanceConstructor=e,this.promise=new e(i),this.promise[g]||f(this.promise),t(h)?(this.length=h.length,this._remaining=h.length,this._result=new Array(this.length),0===this.length?r(this.promise,this._result):(this.length=this.length||0,this._enumerate(h),0===this._remaining&&r(this.promise,this._result))):s(this.promise,new Error("Array Methods must be provided an Array"))}_enumerate(t){for(let e=0;this._state===o&&e<t.length;e++)this._eachEntry(t[e],e)}_eachEntry(t,e){let r=this._instanceConstructor,{resolve:h}=r;if(h===p){let h,l,n=!1;try{h=t.then}catch(t){n=!0,l=t}if(h===u&&t._state!==o)this._settledAt(t._state,e,t._result);else if("function"!=typeof h)this._remaining--,this._result[e]=t;else if(r===a){let o=new r(i);n?s(o,l):m(o,t,h),this._willSettleAt(o,e)}else this._willSettleAt(new r(e=>e(t)),e)}else this._willSettleAt(h(t),e)}_settledAt(t,e,i){let{promise:h}=this;h._state===o&&(this._remaining--,t===n?s(h,i):this._result[e]=i),0===this._remaining&&r(h,this._result)}_willSettleAt(t,e){let i=this;h(t,void 0,t=>i._settledAt(l,e,t),t=>i._settledAt(n,e,t))}};