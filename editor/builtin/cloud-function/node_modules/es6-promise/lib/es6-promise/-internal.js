import{objectOrFunction as t,isFunction as r}from"./utils";import{asap as e}from"./asap";import n from"./then";import o from"./promise/resolve";export const PROMISE_ID=Math.random().toString(36).substring(2);function s(){}const i=void 0,c=1,u=2;function l(t,s,i){s.constructor===t.constructor&&i===n&&s.constructor.resolve===o?function(t,r){r._state===c?a(t,r._result):r._state===u?h(t,r._result):m(r,void 0,r=>f(t,r),r=>h(t,r))}(t,s):void 0===i?a(t,s):r(i)?function(t,r,n){e(t=>{let e=!1,o=function(t,r,e,n){try{t.call(r,e,n)}catch(t){return t}}(n,r,n=>{e||(e=!0,r!==n?f(t,n):a(t,n))},r=>{e||(e=!0,h(t,r))},t._label);!e&&o&&(e=!0,h(t,o))},t)}(t,s,i):a(t,s)}function f(r,e){if(r===e)h(r,new TypeError("You cannot resolve a promise with itself"));else if(t(e)){let t;try{t=e.then}catch(t){return h(r,t),void 0}l(r,e,t)}else a(r,e)}function _(t){t._onerror&&t._onerror(t._result),b(t)}function a(t,r){t._state===i&&(t._result=r,t._state=c,0!==t._subscribers.length&&e(b,t))}function h(t,r){t._state===i&&(t._state=u,t._result=r,e(_,t))}function m(t,r,n,o){let{_subscribers:s}=t,{length:i}=s;t._onerror=null,s[i]=r,s[i+c]=n,s[i+u]=o,0===i&&t._state&&e(b,t)}function b(t){let r=t._subscribers,e=t._state;if(0===r.length)return;let n,o,s=t._result;for(let t=0;t<r.length;t+=3)n=r[t],o=r[t+e],n?p(e,n,o,s):o(s);t._subscribers.length=0}function p(t,e,n,o){let s,l,_=r(n),m=!0;if(_){try{s=n(o)}catch(t){m=!1,l=t}if(e===s)return h(e,new TypeError("A promises callback cannot return that same promise.")),void 0}else s=o;e._state!==i||(_&&m?f(e,s):!1===m?h(e,l):t===c?a(e,s):t===u&&h(e,s))}function v(t,r){try{r(function(r){f(t,r)},function(r){h(t,r)})}catch(r){h(t,r)}}let d=0;function g(){return d++}function y(t){t[PROMISE_ID]=d++,t._state=void 0,t._result=void 0,t._subscribers=[]}export{g as nextId,y as makePromise,s as noop,f as resolve,h as reject,a as fulfill,m as subscribe,b as publish,_ as publishRejection,v as initializePromise,p as invokeCallback,c as FULFILLED,u as REJECTED,i as PENDING,l as handleMaybeThenable};