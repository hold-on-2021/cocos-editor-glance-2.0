"use strict";const e=require("fs"),r=require("path"),t=require("stream"),s=require("tar-stream"),i=require("../utils"),a=require("get-ready");class n extends t.Transform{constructor(a){super(a);const n=s.pack();n.on("data",e=>this.push(e)),n.on("end",()=>this.ready(!0));const o=i.sourceType(a.source);if("file"===o)e.stat(a.source,(t,s)=>{if(t)return this.emit("error",t);this.entry=n.entry({name:a.relativePath||r.basename(a.source),size:s.size,mode:511&s.mode},e=>{if(e)return this.emit("error",e);n.finalize()});const i=e.createReadStream(a.source,a.fs);i.on("error",e=>this.emit("error",e)),i.pipe(this)});else if("buffer"===o){if(!a.relativePath)return this.emit("error","opts.relativePath is required if opts.source is a buffer");n.entry({name:a.relativePath},a.source),n.finalize(),this.end()}else{if(!a.relativePath)return process.nextTick(()=>this.emit("error","opts.relativePath is required"));if(a.size)this.entry=n.entry({name:a.relativePath,size:a.size},e=>{if(e)return this.emit("error",e);n.finalize()});else{a.suppressSizeWarning||console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.supressSizeWarning: true to suppress this warning");const e=[];this.entry=new t.Writable({write(r,t,s){e.push(r),s()}}),this.entry.on("finish",()=>{n.entry({name:a.relativePath},Buffer.concat(e)),n.finalize()})}"stream"===o&&(a.source.on("error",e=>this.emit("error",e)),a.source.pipe(this))}}_transform(e,r,t){this.entry&&this.entry.write(e,r,t)}_flush(e){this.entry&&this.entry.end(),this.ready(e)}}a.mixin(n.prototype),module.exports=n;