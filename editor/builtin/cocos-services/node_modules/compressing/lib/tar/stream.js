"use strict";const r=require("fs"),e=require("path"),i=require("stream"),t=require("tar-stream"),s=require("../utils"),n=require("../base_stream");module.exports=class extends n{constructor(r){super(r),this._waitingEntries=[],this._processing=!1,this._init(r)}_init(){const r=this._pack=t.pack();r.on("end",()=>this.push(null)),r.on("data",r=>this.push(r)),r.on("error",r=>this.emit("error",r))}addEntry(r,e){if(this._processing)return this._waitingEntries.push([r,e]);e=e||{},this._processing=!0;const i=s.entryType(r);i&&("fileOrDir"===i?this._addFileOrDirEntry(r,e):"buffer"===i?this._addBufferEntry(r,e):this._addStreamEntry(r,e))}_addFileOrDirEntry(e,i){r.stat(e,(r,t)=>{if(r)return this.emit("error",r);if(t.isDirectory())return this._addDirEntry(e,i);if(t.isFile())return this._addFileEntry(e,i);const s=new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");s.name="IlligalEntryError",this.emit("error",s)})}_addFileEntry(i,t){r.stat(i,(s,n)=>{if(s)return this.emit("error",s);const a=this._pack.entry({name:t.relativePath||e.basename(i),size:n.size,mode:511&n.mode},this._onEntryFinish.bind(this)),o=r.createReadStream(i,t.fs);o.on("error",r=>this.emit("error",r)),o.pipe(a)})}_addDirEntry(i,t){r.readdir(i,(r,n)=>{if(r)return this.emit("error",r);const a=t.relativePath||"";n.forEach(r=>{const n=s.clone(t);t.ignoreBase?n.relativePath=e.join(a,r):n.relativePath=e.join(a,e.basename(i),r),n.ignoreBase=!0,this.addEntry(e.join(i,r),n)}),this._onEntryFinish()})}_addBufferEntry(r,e){if(!e.relativePath)return this.emit("error","opts.relativePath is required if entry is a buffer");this._pack.entry({name:e.relativePath},r,this._onEntryFinish.bind(this))}_addStreamEntry(r,e){if(r.on("error",r=>this.emit("error",r)),!e.relativePath)return this.emit("error",new Error("opts.relativePath is required"));if(e.size){const i=this._pack.entry({name:e.relativePath,size:e.size},this._onEntryFinish.bind(this));r.pipe(i)}else{e.suppressSizeWarning||console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.supressSizeWarning: true to suppress this warning");const t=[],s=new i.Writable({write(r,e,i){t.push(r),i()}});s.on("error",r=>this.emit("error",r)),s.on("finish",()=>{this._pack.entry({name:e.relativePath},Buffer.concat(t),this._onEntryFinish.bind(this))}),r.pipe(s)}}_read(){}_onEntryFinish(r){if(r)return this.emit("error",r);this._processing=!1;const e=this._waitingEntries.shift();e?this.addEntry.apply(this,e):this._finalize()}_finalize(){this._pack.finalize()}};