"use strict";var e=require("fs"),r=require("big-integer"),t=!1;exports.maxObjectSize=1e8,exports.maxObjectCount=32768;var a=9783072e5,o=exports.UID=function(e){this.UID=e},n=(exports.parseFile=function(r,t){function a(e){var r,a=null;try{r=n(e)}catch(e){a=e}t(a,r)}if(Buffer.isBuffer(r))return a(r);e.readFile(r,function(e,r){if(e)return t(e);a(r)})},exports.parseBuffer=function(e){if("bplist"!==e.slice(0,"bplist".length).toString("utf8"))throw new Error("Invalid binary plist. Expected 'bplist' at offset 0.");var n=e.slice(e.length-32,e.length),s=n.readUInt8(6);t&&console.log("offsetSize: "+s);var c=n.readUInt8(7);t&&console.log("objectRefSize: "+c);var u=l(n,8);t&&console.log("numObjects: "+u);var f=l(n,16);t&&console.log("topObject: "+f);var v=l(n,24);if(t&&console.log("offsetTableOffset: "+v),u>exports.maxObjectCount)throw new Error("maxObjectCount exceeded");for(var p=[],b=0;b<u;b++){var x=e.slice(v+b*s,v+(b+1)*s);p[b]=i(x,0),t&&console.log("Offset for Object #"+b+" is "+p[b]+" ["+p[b].toString(16)+"]")}return[function n(l){var s=p[l],u=e[s],f=(240&u)>>4,v=15&u;switch(f){case 0:return function(){switch(v){case 0:return null;case 8:return!1;case 9:return!0;case 15:return null;default:throw new Error("Unhandled simple type 0x"+f.toString(16))}}();case 1:return function(){var t=Math.pow(2,v);if(t>4){var a=e.slice(s+1,s+1+t),o=function(e){var r,t="";for(r=0;r<e.length&&0==e[r];r++);for(;r<e.length;r++){var a="00"+e[r].toString(16);t+=a.substr(a.length-2)}return t}(a);return r(o,16)}if(t<exports.maxObjectSize)return i(e.slice(s+1,s+1+t));throw new Error("To little heap space available! Wanted to read "+t+" bytes, but only "+exports.maxObjectSize+" are available.")}();case 8:return function(){var r=v+1;if(r<exports.maxObjectSize)return new o(i(e.slice(s+1,s+1+r)));throw new Error("To little heap space available! Wanted to read "+r+" bytes, but only "+exports.maxObjectSize+" are available.")}();case 2:return function(){var r=Math.pow(2,v);if(!(r<exports.maxObjectSize))throw new Error("To little heap space available! Wanted to read "+r+" bytes, but only "+exports.maxObjectSize+" are available.");var t=e.slice(s+1,s+1+r);return 4===r?t.readFloatBE(0):8===r?t.readDoubleBE(0):void 0}();case 3:return function(){3!=v&&console.error("Unknown date type :"+v+". Parsing anyway...");var r=e.slice(s+1,s+9);return new Date(a+1e3*r.readDoubleBE(0))}();case 4:return function(){var r=1,t=v;if(15==v){var a=e[s+1],o=(240&a)/16;1!=o&&console.error("0x4: UNEXPECTED LENGTH-INT TYPE! "+o);var n=15&a,l=Math.pow(2,n);r=2+l,l<3,t=i(e.slice(s+2,s+2+l))}if(t<exports.maxObjectSize)return e.slice(s+r,s+r+t);throw new Error("To little heap space available! Wanted to read "+t+" bytes, but only "+exports.maxObjectSize+" are available.")}();case 5:return b();case 6:return b(!0);case 10:return function(){var r=v,t=1;if(15==v){var a=e[s+1],o=(240&a)/16;1!=o&&console.error("0xa: UNEXPECTED LENGTH-INT TYPE! "+o);var l=15&a,u=Math.pow(2,l);t=2+u,u<3,r=i(e.slice(s+2,s+2+u))}if(r*c>exports.maxObjectSize)throw new Error("To little heap space available!");for(var f=[],p=0;p<r;p++){var b=i(e.slice(s+t+p*c,s+t+(p+1)*c));f[p]=n(b)}return f}();case 13:return function(){var r=v,a=1;if(15==v){var o=e[s+1],u=(240&o)/16;1!=u&&console.error("0xD: UNEXPECTED LENGTH-INT TYPE! "+u);var f=15&o,p=Math.pow(2,f);a=2+p,p<3,r=i(e.slice(s+2,s+2+p))}if(2*r*c>exports.maxObjectSize)throw new Error("To little heap space available!");t&&console.log("Parsing dictionary #"+l);for(var b={},x=0;x<r;x++){var h=i(e.slice(s+a+x*c,s+a+(x+1)*c)),E=i(e.slice(s+a+r*c+x*c,s+a+r*c+(x+1)*c)),w=n(h),d=n(E);t&&console.log("  DICT #"+l+": Mapped "+w+" to "+d),b[w]=d}return b}();default:throw new Error("Unhandled type 0x"+f.toString(16))}function b(r){r=r||0;var t="utf8",a=v,o=1;if(15==v){var n=e[s+1],l=(240&n)/16;1!=l&&console.err("UNEXPECTED LENGTH-INT TYPE! "+l);var c=15&n,u=Math.pow(2,c);o=2+u,u<3,a=i(e.slice(s+2,s+2+u))}if((a*=r+1)<exports.maxObjectSize){var f=new Buffer(e.slice(s+o,s+o+a));return r&&(f=function(e){for(var r=e.length,t=0;t<r;t+=2){var a=e[t];e[t]=e[t+1],e[t+1]=a}return e}(f),t="ucs2"),f.toString(t)}throw new Error("To little heap space available! Wanted to read "+a+" bytes, but only "+exports.maxObjectSize+" are available.")}}(f)]});function i(e,r){for(var t=0,a=r=r||0;a<e.length;a++)t<<=8,t|=255&e[a];return t}function l(e,r){return e.slice(r,r+8).readUInt32BE(4,8)}