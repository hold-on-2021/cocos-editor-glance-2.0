"use strict";
const {
    EventEmitter: EventEmitter
} = require("events"), fs = require("fs"), ps = require("path"), ipc = require("@base/electron-base-ipc"), utils = require("../utils"), data = require("./data"), Profile = require("./profile"), pkg = require("../../package.json"), ipcFlag = `${pkg.name}@${pkg.version}`;
class ProfileManager extends EventEmitter {
    constructor() {
        super(), this._type2path = Object.create(null), this._type2inherit = Object.create(null)
    }
    register(e, t) {
        if (!fs.existsSync(t)) return void console.log(`The registration profile failed: '${t}' does not exist.`);
        fs.statSync(t).isDirectory() ? this._type2path[e] = t : console.log(`The registration profile failed: '${t}' is not a folder.`)
    }
    query(e) {
        return this._type2path[e] || ""
    }
    inherit(e, t) {
        return t && (this._type2inherit[e] = t), this._type2inherit[e] || ""
    }
    clear() {
        this._type2path = Object.create(null), this._type2inherit = Object.create(null), data.clear()
    }
    load(e) {
        const t = utils.formatUrl(e);
        if (!t || !this._type2path[t.type]) return console.warn(`Load profile failed: ${e}`), null;
        data.load(ps.join(this._type2path[t.type], t.path));
        const r = [];
        let a = t.type;
        for (; a;) r.push({
            type: a,
            path: this._type2path[a]
        }), a = manager.inherit(a);
        return new Profile(t.path, t.type, r)
    }
}
let manager = module.exports = new ProfileManager;
ipc.on(`${ipcFlag}:save`, (e, t, r) => {
    let a = manager.query(t);
    if (!a) return void e.reply(new Error(`Profile save failed: profile://${t}${r}`));
    let i = ps.join(a, r);
    data.save(i), e.reply && e.reply(), manager.emit("change", `${t}://${r}`), ipc.broadcast(`${ipcFlag}:change`, t, r)
}), ipc.on(`${ipcFlag}:get`, (e, t, r, a, i) => {
    i = i || {};
    const p = [];
    if (!a) {
        for (; t;) {
            const e = data.load(ps.join(manager._type2path[t], r)) || {};
            if ("current" === i.type) return e;
            if ("deep" !== i.type) return e;
            p.push(e), t = manager.inherit(t)
        }
        const e = {};
        let a = p.pop();
        for (; a;) utils.mergeJSON(e, a), a = p.pop();
        return e
    }
    let n = a.split(".");
    for (; t;) {
        const e = data.load(ps.join(manager._type2path[t], r)),
            a = utils.findData(e, n);
        if ("current" === i.type) return a;
        if (void 0 !== a) {
            if ("deep" !== i.type) return a;
            p.push(a)
        }
        t = manager.inherit(t)
    }
    if (utils.isJSON(p[0])) {
        let e = p.pop();
        const t = {};
        for (; e;) utils.isJSON(e) && utils.mergeJSON(t, e), e = p.pop();
        return t
    }
    return p[0]
}), ipc.on(`${ipcFlag}:set`, (e, t, r, a, i) => {
    data.set(ps.join(manager._type2path[t], r), a, i)
}), ipc.on(`${ipcFlag}:remove`, (e, t, r, a) => {
    data.remove(ps.join(manager._type2path[t], r), a)
}), ipc.on(`${ipcFlag}:clear`, (e, t, r) => {
    try {
        data.empty(ps.join(manager._type2path[t], r)), e.reply()
    } catch (t) {
        e.reply(t)
    }
}), ipc.on(`${ipcFlag}:reset`, (e, t, r) => {
    try {
        data.load(ps.join(manager._type2path[t], r), !0), e.reply()
    } catch (t) {
        e.reply(t)
    }
});